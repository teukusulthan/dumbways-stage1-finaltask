{"version":3,"file":"index.js","sources":["../../lib/generation/util.ts","../../lib/generation/printer.ts","../../lib/generation/print.ts","../../lib/keywords.ts","../../../debug-util/lib/present.ts","../../lib/source/location.ts","../../lib/source/loc/kinds.ts","../../lib/source/loc/match.ts","../../lib/source/slice.ts","../../lib/source/loc/span.ts","../../lib/source/loc/offset.ts","../../lib/source/source.ts","../../lib/source/span-list.ts","../../lib/syntax-error.ts","../../lib/v1/visitor-keys.ts","../../lib/traversal/errors.ts","../../lib/traversal/path.ts","../../lib/traversal/traverse.ts","../../lib/traversal/walker.ts","../../lib/utils.ts","../../lib/v1/public-builders.ts","../../lib/v1/parser-builders.ts","../../lib/v1/legacy-interop.ts","../../lib/parser.ts","../../lib/parser/handlebars-node-visitors.ts","../../lib/parser/tokenizer-event-handlers.ts","../../lib/get-template-locals.ts","../../lib/v2/objects/node.ts","../../lib/v2/objects/args.ts","../../lib/v2/objects/attr-block.ts","../../lib/v2/objects/content.ts","../../lib/v2/objects/expr.ts","../../lib/v2/objects/internal-node.ts","../../lib/v2/objects/refs.ts","../../lib/v2/objects/constants.ts","../../lib/v2/objects/resolution.ts","../../lib/symbol-table.ts","../../lib/v2/builders.ts","../../lib/v2/loose-resolution.ts","../../lib/v2/normalize.ts"],"sourcesContent":["import type * as ASTv1 from '../v1/api';\n\nconst Char = {\n  NBSP: 0xa0,\n  QUOT: 0x22,\n  LT: 0x3c,\n  GT: 0x3e,\n  AMP: 0x26,\n};\n\n// \\x26 is ampersand, \\xa0 is non-breaking space\nconst ATTR_VALUE_REGEX_TEST = /[\"\\x26\\xa0]/u;\nconst ATTR_VALUE_REGEX_REPLACE = new RegExp(ATTR_VALUE_REGEX_TEST.source, 'gu');\n\nconst TEXT_REGEX_TEST = /[&<>\\xa0]/u;\nconst TEXT_REGEX_REPLACE = new RegExp(TEXT_REGEX_TEST.source, 'gu');\n\nfunction attrValueReplacer(char: string): string {\n  switch (char.charCodeAt(0)) {\n    case Char.NBSP:\n      return '&nbsp;';\n    case Char.QUOT:\n      return '&quot;';\n    case Char.AMP:\n      return '&amp;';\n    default:\n      return char;\n  }\n}\n\nfunction textReplacer(char: string): string {\n  switch (char.charCodeAt(0)) {\n    case Char.NBSP:\n      return '&nbsp;';\n    case Char.AMP:\n      return '&amp;';\n    case Char.LT:\n      return '&lt;';\n    case Char.GT:\n      return '&gt;';\n    default:\n      return char;\n  }\n}\n\nexport function escapeAttrValue(attrValue: string): string {\n  if (ATTR_VALUE_REGEX_TEST.test(attrValue)) {\n    return attrValue.replace(ATTR_VALUE_REGEX_REPLACE, attrValueReplacer);\n  }\n  return attrValue;\n}\n\nexport function escapeText(text: string): string {\n  if (TEXT_REGEX_TEST.test(text)) {\n    return text.replace(TEXT_REGEX_REPLACE, textReplacer);\n  }\n  return text;\n}\n\nexport function sortByLoc(a: ASTv1.Node, b: ASTv1.Node): -1 | 0 | 1 {\n  // If either is invisible, don't try to order them\n  if (a.loc.isInvisible || b.loc.isInvisible) {\n    return 0;\n  }\n\n  if (a.loc.startPosition.line < b.loc.startPosition.line) {\n    return -1;\n  }\n\n  if (\n    a.loc.startPosition.line === b.loc.startPosition.line &&\n    a.loc.startPosition.column < b.loc.startPosition.column\n  ) {\n    return -1;\n  }\n\n  if (\n    a.loc.startPosition.line === b.loc.startPosition.line &&\n    a.loc.startPosition.column === b.loc.startPosition.column\n  ) {\n    return 0;\n  }\n\n  return 1;\n}\n","import type * as ASTv1 from '../v1/api';\n\nimport { escapeAttrValue, escapeText, sortByLoc } from './util';\n\nexport const voidMap = new Set([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n]);\n\nexport function getVoidTags() {\n  return [...voidMap];\n}\n\nconst NON_WHITESPACE = /^\\S/u;\n\nexport interface PrinterOptions {\n  entityEncoding: ASTv1.EntityEncodingState;\n\n  /**\n   * Used to override the mechanism of printing a given AST.Node.\n   *\n   * This will generally only be useful to source -> source codemods\n   * where you would like to specialize/override the way a given node is\n   * printed (e.g. you would like to preserve as much of the original\n   * formatting as possible).\n   *\n   * When the provided override returns undefined, the default built in printing\n   * will be done for the AST.Node.\n   *\n   * @param ast the ast node to be printed\n   * @param options the options specified during the print() invocation\n   */\n  override?(ast: ASTv1.Node, options: PrinterOptions): void | string;\n}\n\n/**\n * Examples when true:\n *  - link\n *  - liNK\n *\n * Examples when false:\n *  - Link (component)\n */\nexport function isVoidTag(tag: string): boolean {\n  return voidMap.has(tag.toLowerCase()) && tag[0]?.toLowerCase() === tag[0];\n}\n\nexport default class Printer {\n  private buffer = '';\n  private options: PrinterOptions;\n\n  constructor(options: PrinterOptions) {\n    this.options = options;\n  }\n\n  /*\n    This is used by _all_ methods on this Printer class that add to `this.buffer`,\n    it allows consumers of the printer to use alternate string representations for\n    a given node.\n\n    The primary use case for this are things like source -> source codemod utilities.\n    For example, ember-template-recast attempts to always preserve the original string\n    formatting in each AST node if no modifications are made to it.\n  */\n  handledByOverride(node: ASTv1.Node, ensureLeadingWhitespace = false): boolean {\n    if (this.options.override !== undefined) {\n      let result = this.options.override(node, this.options);\n      if (typeof result === 'string') {\n        if (ensureLeadingWhitespace && NON_WHITESPACE.test(result)) {\n          result = ` ${result}`;\n        }\n\n        this.buffer += result;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  Node(node: ASTv1.Node): void {\n    switch (node.type) {\n      case 'MustacheStatement':\n      case 'BlockStatement':\n      case 'MustacheCommentStatement':\n      case 'CommentStatement':\n      case 'TextNode':\n      case 'ElementNode':\n      case 'AttrNode':\n      case 'Block':\n      case 'Template':\n        return this.TopLevelStatement(node);\n      case 'StringLiteral':\n      case 'BooleanLiteral':\n      case 'NumberLiteral':\n      case 'UndefinedLiteral':\n      case 'NullLiteral':\n      case 'PathExpression':\n      case 'SubExpression':\n        return this.Expression(node);\n      case 'ConcatStatement':\n        // should have an AttrNode parent\n        return this.ConcatStatement(node);\n      case 'Hash':\n        return this.Hash(node);\n      case 'HashPair':\n        return this.HashPair(node);\n      case 'ElementModifierStatement':\n        return this.ElementModifierStatement(node);\n    }\n  }\n\n  Expression(expression: ASTv1.Expression): void {\n    switch (expression.type) {\n      case 'StringLiteral':\n      case 'BooleanLiteral':\n      case 'NumberLiteral':\n      case 'UndefinedLiteral':\n      case 'NullLiteral':\n        return this.Literal(expression);\n      case 'PathExpression':\n        return this.PathExpression(expression);\n      case 'SubExpression':\n        return this.SubExpression(expression);\n    }\n  }\n\n  Literal(literal: ASTv1.Literal): void {\n    switch (literal.type) {\n      case 'StringLiteral':\n        return this.StringLiteral(literal);\n      case 'BooleanLiteral':\n        return this.BooleanLiteral(literal);\n      case 'NumberLiteral':\n        return this.NumberLiteral(literal);\n      case 'UndefinedLiteral':\n        return this.UndefinedLiteral(literal);\n      case 'NullLiteral':\n        return this.NullLiteral(literal);\n    }\n  }\n\n  TopLevelStatement(statement: ASTv1.TopLevelStatement | ASTv1.Template | ASTv1.AttrNode): void {\n    switch (statement.type) {\n      case 'MustacheStatement':\n        return this.MustacheStatement(statement);\n      case 'BlockStatement':\n        return this.BlockStatement(statement);\n      case 'MustacheCommentStatement':\n        return this.MustacheCommentStatement(statement);\n      case 'CommentStatement':\n        return this.CommentStatement(statement);\n      case 'TextNode':\n        return this.TextNode(statement);\n      case 'ElementNode':\n        return this.ElementNode(statement);\n      case 'Block':\n        return this.Block(statement);\n      case 'Template':\n        return this.Template(statement);\n      case 'AttrNode':\n        // should have element\n        return this.AttrNode(statement);\n    }\n  }\n\n  Template(template: ASTv1.Template): void {\n    this.TopLevelStatements(template.body);\n  }\n\n  Block(block: ASTv1.Block): void {\n    /*\n      When processing a template like:\n\n      ```hbs\n      {{#if whatever}}\n        whatever\n      {{else if somethingElse}}\n        something else\n      {{else}}\n        fallback\n      {{/if}}\n      ```\n\n      The AST still _effectively_ looks like:\n\n      ```hbs\n      {{#if whatever}}\n        whatever\n      {{else}}{{#if somethingElse}}\n        something else\n      {{else}}\n        fallback\n      {{/if}}{{/if}}\n      ```\n\n      The only way we can tell if that is the case is by checking for\n      `block.chained`, but unfortunately when the actual statements are\n      processed the `block.body[0]` node (which will always be a\n      `BlockStatement`) has no clue that its ancestor `Block` node was\n      chained.\n\n      This \"forwards\" the `chained` setting so that we can check\n      it later when processing the `BlockStatement`.\n    */\n    if (block.chained) {\n      let firstChild = block.body[0] as ASTv1.BlockStatement;\n      firstChild.chained = true;\n    }\n\n    if (this.handledByOverride(block)) {\n      return;\n    }\n\n    this.TopLevelStatements(block.body);\n  }\n\n  TopLevelStatements(statements: ASTv1.TopLevelStatement[]): void {\n    statements.forEach((statement) => this.TopLevelStatement(statement));\n  }\n\n  ElementNode(el: ASTv1.ElementNode): void {\n    if (this.handledByOverride(el)) {\n      return;\n    }\n\n    this.OpenElementNode(el);\n    this.TopLevelStatements(el.children);\n    this.CloseElementNode(el);\n  }\n\n  OpenElementNode(el: ASTv1.ElementNode): void {\n    this.buffer += `<${el.tag}`;\n    const parts = [...el.attributes, ...el.modifiers, ...el.comments].sort(sortByLoc);\n\n    for (const part of parts) {\n      this.buffer += ' ';\n      switch (part.type) {\n        case 'AttrNode':\n          this.AttrNode(part);\n          break;\n        case 'ElementModifierStatement':\n          this.ElementModifierStatement(part);\n          break;\n        case 'MustacheCommentStatement':\n          this.MustacheCommentStatement(part);\n          break;\n      }\n    }\n    if (el.blockParams.length) {\n      this.BlockParams(el.blockParams);\n    }\n    if (el.selfClosing) {\n      this.buffer += ' /';\n    }\n    this.buffer += '>';\n  }\n\n  CloseElementNode(el: ASTv1.ElementNode): void {\n    if (el.selfClosing || isVoidTag(el.tag)) {\n      return;\n    }\n    this.buffer += `</${el.tag}>`;\n  }\n\n  AttrNode(attr: ASTv1.AttrNode): void {\n    if (this.handledByOverride(attr)) {\n      return;\n    }\n\n    let { name, value } = attr;\n\n    this.buffer += name;\n    const isAttribute = !name.startsWith('@');\n    const shouldElideValue = isAttribute && value.type == 'TextNode' && value.chars.length === 0;\n    if (!shouldElideValue) {\n      this.buffer += '=';\n      this.AttrNodeValue(value);\n    }\n  }\n\n  AttrNodeValue(value: ASTv1.AttrNode['value']): void {\n    if (value.type === 'TextNode') {\n      let quote: '\"' | \"'\" = '\"';\n      if (this.options.entityEncoding === 'raw') {\n        if (value.chars.includes('\"') && !value.chars.includes(\"'\")) {\n          quote = \"'\";\n        }\n      }\n      this.buffer += quote;\n      this.TextNode(value, quote);\n      this.buffer += quote;\n    } else {\n      this.Node(value);\n    }\n  }\n\n  TextNode(text: ASTv1.TextNode, isInAttr?: \"'\" | '\"'): void {\n    if (this.handledByOverride(text)) {\n      return;\n    }\n\n    if (this.options.entityEncoding === 'raw') {\n      if (isInAttr && text.chars.includes(isInAttr)) {\n        this.buffer += escapeAttrValue(text.chars);\n      } else {\n        this.buffer += text.chars;\n      }\n    } else if (isInAttr) {\n      this.buffer += escapeAttrValue(text.chars);\n    } else {\n      this.buffer += escapeText(text.chars);\n    }\n  }\n\n  MustacheStatement(mustache: ASTv1.MustacheStatement): void {\n    if (this.handledByOverride(mustache)) {\n      return;\n    }\n\n    this.buffer += mustache.trusting ? '{{{' : '{{';\n\n    if (mustache.strip.open) {\n      this.buffer += '~';\n    }\n\n    this.Expression(mustache.path);\n    this.Params(mustache.params);\n    this.Hash(mustache.hash);\n\n    if (mustache.strip.close) {\n      this.buffer += '~';\n    }\n\n    this.buffer += mustache.trusting ? '}}}' : '}}';\n  }\n\n  BlockStatement(block: ASTv1.BlockStatement): void {\n    if (this.handledByOverride(block)) {\n      return;\n    }\n\n    if (block.chained) {\n      this.buffer += block.inverseStrip.open ? '{{~' : '{{';\n      this.buffer += 'else ';\n    } else {\n      this.buffer += block.openStrip.open ? '{{~#' : '{{#';\n    }\n\n    this.Expression(block.path);\n    this.Params(block.params);\n    this.Hash(block.hash);\n    if (block.program.blockParams.length) {\n      this.BlockParams(block.program.blockParams);\n    }\n\n    if (block.chained) {\n      this.buffer += block.inverseStrip.close ? '~}}' : '}}';\n    } else {\n      this.buffer += block.openStrip.close ? '~}}' : '}}';\n    }\n\n    this.Block(block.program);\n\n    if (block.inverse) {\n      if (!block.inverse.chained) {\n        this.buffer += block.inverseStrip.open ? '{{~' : '{{';\n        this.buffer += 'else';\n        this.buffer += block.inverseStrip.close ? '~}}' : '}}';\n      }\n\n      this.Block(block.inverse);\n    }\n\n    if (!block.chained) {\n      this.buffer += block.closeStrip.open ? '{{~/' : '{{/';\n      this.Expression(block.path);\n      this.buffer += block.closeStrip.close ? '~}}' : '}}';\n    }\n  }\n\n  BlockParams(blockParams: string[]): void {\n    this.buffer += ` as |${blockParams.join(' ')}|`;\n  }\n\n  ConcatStatement(concat: ASTv1.ConcatStatement): void {\n    if (this.handledByOverride(concat)) {\n      return;\n    }\n\n    this.buffer += '\"';\n    concat.parts.forEach((part) => {\n      if (part.type === 'TextNode') {\n        this.TextNode(part, '\"');\n      } else {\n        this.Node(part);\n      }\n    });\n    this.buffer += '\"';\n  }\n\n  MustacheCommentStatement(comment: ASTv1.MustacheCommentStatement): void {\n    if (this.handledByOverride(comment)) {\n      return;\n    }\n\n    this.buffer += `{{!--${comment.value}--}}`;\n  }\n\n  ElementModifierStatement(mod: ASTv1.ElementModifierStatement): void {\n    if (this.handledByOverride(mod)) {\n      return;\n    }\n\n    this.buffer += '{{';\n    this.Expression(mod.path);\n    this.Params(mod.params);\n    this.Hash(mod.hash);\n    this.buffer += '}}';\n  }\n\n  CommentStatement(comment: ASTv1.CommentStatement): void {\n    if (this.handledByOverride(comment)) {\n      return;\n    }\n\n    this.buffer += `<!--${comment.value}-->`;\n  }\n\n  PathExpression(path: ASTv1.PathExpression): void {\n    if (this.handledByOverride(path)) {\n      return;\n    }\n\n    this.buffer += path.original;\n  }\n\n  SubExpression(sexp: ASTv1.SubExpression): void {\n    if (this.handledByOverride(sexp)) {\n      return;\n    }\n\n    this.buffer += '(';\n    this.Expression(sexp.path);\n    this.Params(sexp.params);\n    this.Hash(sexp.hash);\n    this.buffer += ')';\n  }\n\n  Params(params: ASTv1.Expression[]): void {\n    // TODO: implement a top level Params AST node (just like the Hash object)\n    // so that this can also be overridden\n    if (params.length) {\n      params.forEach((param) => {\n        this.buffer += ' ';\n        this.Expression(param);\n      });\n    }\n  }\n\n  Hash(hash: ASTv1.Hash): void {\n    if (this.handledByOverride(hash, true)) {\n      return;\n    }\n\n    hash.pairs.forEach((pair) => {\n      this.buffer += ' ';\n      this.HashPair(pair);\n    });\n  }\n\n  HashPair(pair: ASTv1.HashPair): void {\n    if (this.handledByOverride(pair)) {\n      return;\n    }\n\n    this.buffer += pair.key;\n    this.buffer += '=';\n    this.Node(pair.value);\n  }\n\n  StringLiteral(str: ASTv1.StringLiteral): void {\n    if (this.handledByOverride(str)) {\n      return;\n    }\n\n    this.buffer += JSON.stringify(str.value);\n  }\n\n  BooleanLiteral(bool: ASTv1.BooleanLiteral): void {\n    if (this.handledByOverride(bool)) {\n      return;\n    }\n\n    this.buffer += String(bool.value);\n  }\n\n  NumberLiteral(number: ASTv1.NumberLiteral): void {\n    if (this.handledByOverride(number)) {\n      return;\n    }\n\n    this.buffer += String(number.value);\n  }\n\n  UndefinedLiteral(node: ASTv1.UndefinedLiteral): void {\n    if (this.handledByOverride(node)) {\n      return;\n    }\n\n    this.buffer += 'undefined';\n  }\n\n  NullLiteral(node: ASTv1.NullLiteral): void {\n    if (this.handledByOverride(node)) {\n      return;\n    }\n\n    this.buffer += 'null';\n  }\n\n  print(node: ASTv1.Node): string {\n    let { options } = this;\n\n    if (options.override) {\n      let result = options.override(node, options);\n\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    this.buffer = '';\n    this.Node(node);\n    return this.buffer;\n  }\n}\n","import type * as ASTv1 from '../v1/api';\nimport type { PrinterOptions } from './printer';\n\nimport Printer from './printer';\n\nexport default function build(\n  ast: ASTv1.Node,\n  options: PrinterOptions = { entityEncoding: 'transformed' }\n): string {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS users\n  if (!ast) {\n    return '';\n  }\n\n  let printer = new Printer(options);\n  return printer.print(ast);\n}\n","export type Keywords = keyof typeof KEYWORDS_TYPES;\nexport type KeywordType = 'Call' | 'Modifier' | 'Append' | 'Block';\n\nexport function isKeyword(word: string): word is Keywords;\nexport function isKeyword(word: string, type: KeywordType): boolean;\nexport function isKeyword(word: string, type?: KeywordType): boolean {\n  if (word in KEYWORDS_TYPES) {\n    if (type === undefined) {\n      return true;\n    } else {\n      let types = KEYWORDS_TYPES[word as Keywords];\n      // This seems like a TypeScript bug – it inferred types as never[]?\n      return types.includes(type as never);\n    }\n  } else {\n    return false;\n  }\n}\n\n/**\n * This includes the full list of keywords currently in use in the template\n * language, and where their valid usages are.\n */\nexport const KEYWORDS_TYPES = {\n  action: ['Call', 'Modifier'],\n  component: ['Call', 'Append', 'Block'],\n  debugger: ['Append'],\n  'each-in': ['Block'],\n  each: ['Block'],\n  'has-block-params': ['Call', 'Append'],\n  'has-block': ['Call', 'Append'],\n  helper: ['Call', 'Append'],\n  if: ['Call', 'Append', 'Block'],\n  'in-element': ['Block'],\n  let: ['Block'],\n  log: ['Call', 'Append'],\n  modifier: ['Call', 'Modifier'],\n  mount: ['Append'],\n  mut: ['Call', 'Append'],\n  outlet: ['Append'],\n  readonly: ['Call', 'Append'],\n  unbound: ['Call', 'Append'],\n  unless: ['Call', 'Append', 'Block'],\n  yield: ['Append'],\n} satisfies Record<string, readonly KeywordType[]>;\n","import type { Nullable, Present, PresentArray } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nexport function isPresent<T>(value: T): value is Present<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function assertPresent<T extends string>(value: T): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message: string): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message?: string): asserts value is Present<T> {\n  if (LOCAL_DEBUG && !isPresent(value)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    throw new Error(`Expected present, got ${typeof value === 'string' ? value : message!}`);\n  }\n}\n\nexport function isPresentArray<T>(list?: readonly T[]): list is PresentArray<T> {\n  return list ? list.length > 0 : false;\n}\n\nexport function ifPresent<T, U, V>(\n  list: T[],\n  ifPresent: (input: PresentArray<T>) => U,\n  otherwise: () => V\n): U | V {\n  if (isPresentArray(list)) {\n    return ifPresent(list);\n  } else {\n    return otherwise();\n  }\n}\n\nexport function arrayToOption<T>(list: T[]): Nullable<PresentArray<T>> {\n  if (isPresentArray(list)) {\n    return list;\n  } else {\n    return null;\n  }\n}\n\nexport function assertPresentArray<T>(\n  list: T[],\n  message = `unexpected empty list`\n): asserts list is PresentArray<T> {\n  if (LOCAL_DEBUG && !isPresentArray(list)) {\n    throw new Error(message);\n  }\n}\n\nexport function asPresentArray<T>(list: T[], message = `unexpected empty list`): PresentArray<T> {\n  assertPresentArray(list, message);\n  return list;\n}\n\nexport function getLast<T>(list: PresentArray<T>): T;\nexport function getLast<T>(list: T[]): T | undefined;\nexport function getLast<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[list.length - 1] as T);\n}\n\nexport function getFirst<T>(list: PresentArray<T>): T;\nexport function getFirst<T>(list: T[]): T | undefined;\nexport function getFirst<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[0] as T);\n}\n\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T>,\n  mapper: (input: T) => U\n): PresentArray<U>;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null {\n  if (list === null) {\n    return null;\n  }\n  let out: U[] = [];\n\n  for (let item of list) {\n    out.push(mapper(item));\n  }\n\n  return out as PresentArray<U>;\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray } from '@glimmer/debug-util';\n\nimport type { SourceSpan } from './span';\n\nexport interface SourceLocation {\n  start: SourcePosition;\n  end: SourcePosition;\n}\n\nexport interface SourcePosition {\n  /** >= 1 */\n  line: number;\n  /** >= 0 */\n  column: number;\n}\n\nexport const UNKNOWN_POSITION = Object.freeze({\n  line: 1,\n  column: 0,\n} as const);\n\nexport const SYNTHETIC_LOCATION = Object.freeze({\n  source: '(synthetic)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\n/** @deprecated */\nexport const SYNTHETIC = SYNTHETIC_LOCATION;\n\nexport const TEMPORARY_LOCATION = Object.freeze({\n  source: '(temporary)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\nexport const NON_EXISTENT_LOCATION = Object.freeze({\n  source: '(nonexistent)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\nexport const BROKEN_LOCATION = Object.freeze({\n  source: '(broken)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\nexport type LocatedWithSpan = { offsets: SourceSpan };\nexport type LocatedWithOptionalSpan = { offsets: SourceSpan | null };\n\nexport type LocatedWithPositions = { loc: SourceLocation };\nexport type LocatedWithOptionalPositions = { loc?: SourceLocation };\n\nexport function isLocatedWithPositionsArray(\n  location: LocatedWithOptionalPositions[]\n): location is PresentArray<LocatedWithPositions> {\n  return isPresentArray(location) && location.every(isLocatedWithPositions);\n}\n\nexport function isLocatedWithPositions(\n  location: LocatedWithOptionalPositions\n): location is LocatedWithPositions {\n  return location.loc !== undefined;\n}\n\nexport type HasSourceLocation =\n  | SourceLocation\n  | LocatedWithPositions\n  | PresentArray<LocatedWithPositions>;\n\nexport type MaybeHasSourceLocation =\n  | null\n  | LocatedWithOptionalPositions\n  | LocatedWithOptionalPositions[];\n","/**\n * We have already computed the character position of this offset or span.\n */\nexport type CharOffsetKind = 'CharPosition';\nexport const CHAR_OFFSET_KIND: CharOffsetKind = 'CharPosition';\n/**\n * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its\n * character position will be computed on demand.\n */\nexport type HbsPositionKind = 'HbsPosition';\nexport const HBS_POSITION_KIND: HbsPositionKind = 'HbsPosition';\n/**\n * for (rare) situations where a node is created but there was no source location (e.g. the name\n * \"default\" in default blocks when the word \"default\" never appeared in source). This is used\n * by the internals when there is a legitimate reason for the internals to synthesize a node\n * with no location.\n */\nexport type InternalSyntheticKind = 'InternalsSynthetic';\nexport const INTERNAL_SYNTHETIC_KIND: InternalSyntheticKind = 'InternalsSynthetic';\n\n/**\n * For situations where a node represents zero parts of the source (for example, empty arguments).\n * In general, we attempt to assign these nodes *some* position (empty arguments can be\n * positioned immediately after the callee), but it's not always possible\n */\nexport type NonExistentKind = 'NonExistent';\nexport const NON_EXISTENT_KIND: NonExistentKind = 'NonExistent';\n\n/**\n * For situations where a source location was expected, but it didn't correspond to the node in\n * the source. This happens if a plugin creates broken locations.\n */\nexport type BrokenKind = 'Broken';\nexport const BROKEN_KIND: BrokenKind = 'Broken';\n\nexport type OffsetKind = CharOffsetKind | HbsPositionKind | InvisibleKind;\n\n/**\n * These kinds  describe spans that don't have a concrete location in the original source.\n */\nexport type InvisibleKind = BrokenKind | InternalSyntheticKind | NonExistentKind;\n\nexport function isInvisible(kind: OffsetKind): kind is InvisibleKind {\n  return kind !== CHAR_OFFSET_KIND && kind !== HBS_POSITION_KIND;\n}\n","import { isPresentArray, localAssert } from '@glimmer/debug-util';\n\nimport type { CharOffsetKind, HbsPositionKind, OffsetKind } from './kinds';\nimport type { CharPosition, HbsPosition, InvisiblePosition, PositionData } from './offset';\n\nimport { BROKEN_KIND, INTERNAL_SYNTHETIC_KIND, NON_EXISTENT_KIND } from './kinds';\n\n/**\n * This file implements the DSL used by span and offset in places where they need to exhaustively\n * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken\n * offsets).\n *\n * It's probably overkill, but it makes the code that uses it clear. It could be refactored or\n * removed.\n */\n\nexport const MatchAny = 'MATCH_ANY';\nexport type MatchAny = 'MATCH_ANY';\n\ntype Matches =\n  | 'Char,Hbs'\n  | 'Hbs,Char'\n  | 'Hbs,Hbs'\n  | 'Char,Char'\n  | 'Invisible,Any'\n  | 'Any,Invisible';\n\nexport const IsInvisible = 'IS_INVISIBLE';\nexport type IsInvisible = 'IS_INVISIBLE';\n\ntype Pattern = OffsetKind | IsInvisible | MatchAny;\n\nclass WhenList<Out> {\n  _whens: When<Out>[];\n\n  constructor(whens: When<Out>[]) {\n    this._whens = whens;\n  }\n\n  first(kind: OffsetKind): Out | null {\n    for (const when of this._whens) {\n      const value = when.match(kind);\n      if (isPresentArray(value)) {\n        return value[0];\n      }\n    }\n\n    return null;\n  }\n}\n\nclass When<Out> {\n  _map: Map<Pattern, Out> = new Map();\n\n  get(pattern: Pattern, or: () => Out): Out {\n    let value = this._map.get(pattern);\n\n    if (value) {\n      return value;\n    }\n\n    value = or();\n\n    this._map.set(pattern, value);\n\n    return value;\n  }\n\n  add(pattern: Pattern, out: Out): void {\n    this._map.set(pattern, out);\n  }\n\n  match(kind: OffsetKind): Out[] {\n    const pattern = patternFor(kind);\n\n    const out: Out[] = [];\n\n    const exact = this._map.get(pattern);\n    const fallback = this._map.get(MatchAny);\n\n    if (exact) {\n      out.push(exact);\n    }\n\n    if (fallback) {\n      out.push(fallback);\n    }\n\n    return out;\n  }\n}\n\ntype ExhaustiveCheck<Out, In extends Matches, Removed extends Matches> =\n  Exclude<In, Removed> extends never ? ExhaustiveMatcher<Out> : Matcher<Out, Exclude<In, Removed>>;\n\nexport type MatchFn<Out> = (left: PositionData, right: PositionData) => Out;\n\ninterface ExhaustiveMatcher<Out> {\n  validate(): MatchFn<Out>;\n}\n\nexport function match<Out>(callback: (m: Matcher<Out>) => ExhaustiveMatcher<Out>): MatchFn<Out> {\n  return callback(new Matcher()).validate();\n}\n\nclass Matcher<Out, M extends Matches = Matches> {\n  _whens: When<When<(left: PositionData, right: PositionData) => Out>> = new When();\n\n  /**\n   * You didn't exhaustively match all possibilities.\n   */\n  protected validate(): MatchFn<Out> {\n    return (left, right) => this.matchFor(left.kind, right.kind)(left, right);\n  }\n\n  private matchFor(\n    left: OffsetKind,\n    right: OffsetKind\n  ): (left: PositionData, right: PositionData) => Out {\n    const nesteds = this._whens.match(left);\n\n    localAssert(\n      isPresentArray(nesteds),\n      `no match defined for (${left}, ${right}) and no AnyMatch defined either`\n    );\n\n    const callback = new WhenList(nesteds).first(right);\n\n    localAssert(\n      callback !== null,\n      `no match defined for (${left}, ${right}) and no AnyMatch defined either`\n    );\n\n    return callback;\n  }\n\n  // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness\n  // checking so that matchers can ensure they've actually covered all the cases (and TypeScript\n  // will treat it as an exhaustive match).\n  when(\n    left: CharOffsetKind,\n    right: HbsPositionKind,\n    callback: (left: CharPosition, right: HbsPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Char,Hbs'>;\n  when(\n    left: HbsPositionKind,\n    right: CharOffsetKind,\n    callback: (left: HbsPosition, right: CharPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Hbs,Char'>;\n  when(\n    left: HbsPositionKind,\n    right: HbsPositionKind,\n    callback: (left: HbsPosition, right: HbsPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Hbs,Hbs'>;\n  when(\n    left: CharOffsetKind,\n    right: CharOffsetKind,\n    callback: (left: CharPosition, right: CharPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Char,Char'>;\n  when(\n    left: IsInvisible,\n    right: MatchAny,\n    callback: (left: InvisiblePosition, right: PositionData) => Out\n  ): Matcher<Out, Exclude<M, 'Invisible,Any'>>;\n  when(\n    left: MatchAny,\n    right: IsInvisible,\n    callback: (left: PositionData, right: InvisiblePosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Any,Invisible'>;\n  when(\n    left: MatchAny,\n    right: MatchAny,\n    callback: (left: PositionData, right: PositionData) => Out\n  ): ExhaustiveMatcher<Out>;\n  when(\n    left: Pattern,\n    right: Pattern,\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (left: any, right: any) => Out\n  ): ExhaustiveCheck<Out, M, M> | Matcher<Out, Exclude<M, M>> {\n    this._whens.get(left, () => new When()).add(right, callback);\n\n    return this;\n  }\n}\n\nfunction patternFor(kind: OffsetKind): Pattern {\n  switch (kind) {\n    case BROKEN_KIND:\n    case INTERNAL_SYNTHETIC_KIND:\n    case NON_EXISTENT_KIND:\n      return IsInvisible;\n    default:\n      return kind;\n  }\n}\n","import * as src from './api';\n\nexport type SerializedSourceSlice<Chars extends string = string> = [\n  chars: Chars,\n  span: src.SerializedSourceSpan,\n];\n\nexport class SourceSlice<Chars extends string = string> {\n  static synthetic<S extends string>(chars: S): SourceSlice<S> {\n    let offsets = src.SourceSpan.synthetic(chars);\n    return new SourceSlice({ loc: offsets, chars: chars });\n  }\n\n  static load(source: src.Source, slice: SerializedSourceSlice): SourceSlice {\n    return new SourceSlice({\n      loc: src.SourceSpan.load(source, slice[1]),\n      chars: slice[0],\n    });\n  }\n\n  readonly chars: Chars;\n  readonly loc: src.SourceSpan;\n\n  constructor(options: { loc: src.SourceSpan; chars: Chars }) {\n    this.loc = options.loc;\n    this.chars = options.chars;\n  }\n\n  getString(): string {\n    return this.chars;\n  }\n\n  serialize(): SerializedSourceSlice<Chars> {\n    return [this.chars, this.loc.serialize()];\n  }\n}\n","import { localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { assertNever } from '@glimmer/util';\n\nimport type { SourceLocation, SourcePosition } from '../location';\nimport type { Source } from '../source';\nimport type { InvisibleKind, OffsetKind } from './kinds';\nimport type { MatchFn } from './match';\nimport type { AnyPosition, SourceOffset } from './offset';\n\nimport { BROKEN_LOCATION, NON_EXISTENT_LOCATION } from '../location';\nimport { SourceSlice } from '../slice';\nimport {\n  BROKEN_KIND,\n  CHAR_OFFSET_KIND,\n  HBS_POSITION_KIND,\n  INTERNAL_SYNTHETIC_KIND,\n  isInvisible,\n  NON_EXISTENT_KIND,\n} from './kinds';\nimport { IsInvisible, match, MatchAny } from './match';\nimport { BROKEN, CharPosition, HbsPosition, InvisiblePosition } from './offset';\n\n/**\n * All spans have these details in common.\n */\ninterface SpanData {\n  readonly kind: OffsetKind;\n\n  /**\n   * Convert this span into a string. If the span is broken, return `''`.\n   */\n  asString(): string;\n\n  /**\n   * Gets the module the span was located in.\n   */\n  getModule(): string;\n\n  /**\n   * Get the starting position for this span. Try to avoid creating new position objects, as they\n   * cache computations.\n   */\n  getStart(): AnyPosition;\n\n  /**\n   * Get the ending position for this span. Try to avoid creating new position objects, as they\n   * cache computations.\n   */\n  getEnd(): AnyPosition;\n\n  /**\n   * Compute the `SourceLocation` for this span, returned as an instance of `HbsSpan`.\n   */\n  toHbsSpan(): HbsSpan | null;\n\n  /**\n   * For compatibility, whenever the `start` or `end` of a {@see SourceOffset} changes, spans are\n   * notified of the change so they can update themselves. This shouldn't happen outside of AST\n   * plugins.\n   */\n  locDidUpdate(changes: { start?: SourcePosition; end?: SourcePosition }): void;\n\n  /**\n   * Serialize into a {@see SerializedSourceSpan}, which is compact and designed for readability in\n   * context like AST Explorer. If you need a {@see SourceLocation}, use {@see toJSON}.\n   */\n  serialize(): SerializedSourceSpan;\n}\n\n/**\n * A `SourceSpan` object represents a span of characters inside of a template source.\n *\n * There are three kinds of `SourceSpan` objects:\n *\n * - `ConcreteSourceSpan`, which contains byte offsets\n * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be\n *   converted to byte offsets on demand.\n * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,\n *   because:\n *     - they were created synthetically\n *     - their location is nonsensical (the span is broken)\n *     - they represent nothing in the source (this currently happens only when a bug in the\n *       upstream Handlebars parser fails to assign a location to empty blocks)\n *\n * At a high level, all `SourceSpan` objects provide:\n *\n * - byte offsets\n * - source in column and line format\n *\n * And you can do these operations on `SourceSpan`s:\n *\n * - collapse it to a `SourceSpan` representing its starting or ending position\n * - slice out some characters, optionally skipping some characters at the beginning or end\n * - create a new `SourceSpan` with a different starting or ending offset\n *\n * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan\n * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.\n *\n * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which\n * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.\n *\n * The goal is to avoid creating any problems for use-cases like AST Explorer.\n */\nexport class SourceSpan implements SourceLocation {\n  static get NON_EXISTENT(): SourceSpan {\n    return new InvisibleSpan(NON_EXISTENT_KIND, NON_EXISTENT_LOCATION).wrap();\n  }\n\n  static load(source: Source, serialized: SerializedSourceSpan): SourceSpan {\n    if (typeof serialized === 'number') {\n      return SourceSpan.forCharPositions(source, serialized, serialized);\n    } else if (typeof serialized === 'string') {\n      return SourceSpan.synthetic(serialized);\n    } else if (Array.isArray(serialized)) {\n      return SourceSpan.forCharPositions(source, serialized[0], serialized[1]);\n    } else if (serialized === NON_EXISTENT_KIND) {\n      return SourceSpan.NON_EXISTENT;\n    } else if (serialized === BROKEN_KIND) {\n      return SourceSpan.broken(BROKEN_LOCATION);\n    }\n\n    assertNever(serialized);\n  }\n\n  static forHbsLoc(source: Source, loc: SourceLocation): SourceSpan {\n    const start = new HbsPosition(source, loc.start);\n    const end = new HbsPosition(source, loc.end);\n    return new HbsSpan(source, { start, end }, loc).wrap();\n  }\n\n  static forCharPositions(source: Source, startPos: number, endPos: number): SourceSpan {\n    const start = new CharPosition(source, startPos);\n    const end = new CharPosition(source, endPos);\n\n    return new CharPositionSpan(source, { start, end }).wrap();\n  }\n\n  static synthetic(chars: string): SourceSpan {\n    return new InvisibleSpan(INTERNAL_SYNTHETIC_KIND, NON_EXISTENT_LOCATION, chars).wrap();\n  }\n\n  static broken(pos: SourceLocation = BROKEN_LOCATION): SourceSpan {\n    return new InvisibleSpan(BROKEN_KIND, pos).wrap();\n  }\n\n  readonly isInvisible: boolean;\n\n  constructor(private data: SpanData & AnySpan) {\n    this.isInvisible = isInvisible(data.kind);\n  }\n\n  getStart(): SourceOffset {\n    return this.data.getStart().wrap();\n  }\n\n  getEnd(): SourceOffset {\n    return this.data.getEnd().wrap();\n  }\n\n  get loc(): SourceLocation {\n    const span = this.data.toHbsSpan();\n    return span === null ? BROKEN_LOCATION : span.toHbsLoc();\n  }\n\n  get module(): string {\n    return this.data.getModule();\n  }\n\n  /**\n   * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.\n   */\n  get startPosition(): SourcePosition {\n    return this.loc.start;\n  }\n\n  /**\n   * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.\n   */\n  get endPosition(): SourcePosition {\n    return this.loc.end;\n  }\n\n  /**\n   * Support converting ASTv1 nodes into a serialized format using JSON.stringify.\n   */\n  toJSON(): SourceLocation {\n    return this.loc;\n  }\n\n  /**\n   * Create a new span with the current span's end and a new beginning.\n   */\n  withStart(other: SourceOffset): SourceSpan {\n    return span(other.data, this.data.getEnd());\n  }\n\n  /**\n   * Create a new span with the current span's beginning and a new ending.\n   */\n  withEnd(other: SourceOffset): SourceSpan {\n    return span(this.data.getStart(), other.data);\n  }\n\n  asString(): string {\n    return this.data.asString();\n  }\n\n  /**\n   * Convert this `SourceSpan` into a `SourceSlice`.\n   */\n  toSlice(expected?: string): SourceSlice {\n    const chars = this.data.asString();\n\n    localAssert(\n      expected === undefined || expected === chars,\n      `unexpectedly found ${JSON.stringify(chars)} when slicing source, ` +\n        `but expected ${JSON.stringify(expected)}`\n    );\n\n    return new SourceSlice({\n      loc: this,\n      chars: expected || chars,\n    });\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use startPosition instead\n   */\n  get start(): SourcePosition {\n    return this.loc.start;\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use withStart instead\n   */\n  set start(position: SourcePosition) {\n    this.data.locDidUpdate({ start: position });\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use endPosition instead\n   */\n  get end(): SourcePosition {\n    return this.loc.end;\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use withEnd instead\n   */\n  set end(position: SourcePosition) {\n    this.data.locDidUpdate({ end: position });\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use module instead\n   */\n  get source(): string {\n    return this.module;\n  }\n\n  collapse(where: 'start' | 'end'): SourceSpan {\n    switch (where) {\n      case 'start':\n        return this.getStart().collapsed();\n      case 'end':\n        return this.getEnd().collapsed();\n    }\n  }\n\n  extend(other: SourceSpan): SourceSpan {\n    return span(this.data.getStart(), other.data.getEnd());\n  }\n\n  serialize(): SerializedSourceSpan {\n    return this.data.serialize();\n  }\n\n  slice({ skipStart = 0, skipEnd = 0 }: { skipStart?: number; skipEnd?: number }): SourceSpan {\n    return span(this.getStart().move(skipStart).data, this.getEnd().move(-skipEnd).data);\n  }\n\n  sliceStartChars({ skipStart = 0, chars }: { skipStart?: number; chars: number }): SourceSpan {\n    return span(this.getStart().move(skipStart).data, this.getStart().move(skipStart + chars).data);\n  }\n\n  sliceEndChars({ skipEnd = 0, chars }: { skipEnd?: number; chars: number }): SourceSpan {\n    return span(this.getEnd().move(skipEnd - chars).data, this.getStart().move(-skipEnd).data);\n  }\n}\n\ntype AnySpan = HbsSpan | CharPositionSpan | InvisibleSpan;\n\nclass CharPositionSpan implements SpanData {\n  readonly kind = CHAR_OFFSET_KIND;\n\n  #locPosSpan: HbsSpan | BROKEN | null = null;\n\n  constructor(\n    readonly source: Source,\n    readonly charPositions: { start: CharPosition; end: CharPosition }\n  ) {}\n\n  wrap(): SourceSpan {\n    return new SourceSpan(this);\n  }\n\n  asString(): string {\n    return this.source.slice(this.charPositions.start.charPos, this.charPositions.end.charPos);\n  }\n\n  getModule(): string {\n    return this.source.module;\n  }\n\n  getStart(): AnyPosition {\n    return this.charPositions.start;\n  }\n\n  getEnd(): AnyPosition {\n    return this.charPositions.end;\n  }\n\n  locDidUpdate() {\n    if (LOCAL_DEBUG) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `updating a location that came from a CharPosition span doesn't work reliably. Don't try to update locations after the plugin phase`\n      );\n    }\n  }\n\n  toHbsSpan(): HbsSpan | null {\n    let locPosSpan = this.#locPosSpan;\n\n    if (locPosSpan === null) {\n      const start = this.charPositions.start.toHbsPos();\n      const end = this.charPositions.end.toHbsPos();\n\n      if (start === null || end === null) {\n        locPosSpan = this.#locPosSpan = BROKEN;\n      } else {\n        locPosSpan = this.#locPosSpan = new HbsSpan(this.source, {\n          start,\n          end,\n        });\n      }\n    }\n\n    return locPosSpan === BROKEN ? null : locPosSpan;\n  }\n\n  serialize(): SerializedSourceSpan {\n    const {\n      start: { charPos: start },\n      end: { charPos: end },\n    } = this.charPositions;\n\n    if (start === end) {\n      return start;\n    } else {\n      return [start, end];\n    }\n  }\n\n  toCharPosSpan(): this {\n    return this;\n  }\n}\n\nexport class HbsSpan implements SpanData {\n  readonly kind = HBS_POSITION_KIND;\n\n  #charPosSpan: CharPositionSpan | BROKEN | null = null;\n\n  // the source location from Handlebars + AST Plugins -- could be wrong\n  #providedHbsLoc: SourceLocation | null;\n\n  constructor(\n    readonly source: Source,\n    readonly hbsPositions: { start: HbsPosition; end: HbsPosition },\n    providedHbsLoc: SourceLocation | null = null\n  ) {\n    this.#providedHbsLoc = providedHbsLoc;\n  }\n\n  serialize(): SerializedConcreteSourceSpan {\n    const charPos = this.toCharPosSpan();\n    return charPos === null ? BROKEN_KIND : charPos.wrap().serialize();\n  }\n\n  wrap(): SourceSpan {\n    return new SourceSpan(this);\n  }\n\n  private updateProvided(pos: SourcePosition, edge: 'start' | 'end') {\n    if (this.#providedHbsLoc) {\n      this.#providedHbsLoc[edge] = pos;\n    }\n\n    // invalidate computed character offsets\n    this.#charPosSpan = null;\n    this.#providedHbsLoc = {\n      start: pos,\n      end: pos,\n    };\n  }\n\n  locDidUpdate({ start, end }: { start?: SourcePosition; end?: SourcePosition }): void {\n    if (start !== undefined) {\n      this.updateProvided(start, 'start');\n      this.hbsPositions.start = new HbsPosition(this.source, start, null);\n    }\n\n    if (end !== undefined) {\n      this.updateProvided(end, 'end');\n      this.hbsPositions.end = new HbsPosition(this.source, end, null);\n    }\n  }\n\n  asString(): string {\n    const span = this.toCharPosSpan();\n    return span === null ? '' : span.asString();\n  }\n\n  getModule(): string {\n    return this.source.module;\n  }\n\n  getStart(): AnyPosition {\n    return this.hbsPositions.start;\n  }\n\n  getEnd(): AnyPosition {\n    return this.hbsPositions.end;\n  }\n\n  toHbsLoc(): SourceLocation {\n    return {\n      start: this.hbsPositions.start.hbsPos,\n      end: this.hbsPositions.end.hbsPos,\n    };\n  }\n\n  toHbsSpan(): this {\n    return this;\n  }\n\n  toCharPosSpan(): CharPositionSpan | null {\n    let charPosSpan = this.#charPosSpan;\n\n    if (charPosSpan === null) {\n      const start = this.hbsPositions.start.toCharPos();\n      const end = this.hbsPositions.end.toCharPos();\n\n      if (start && end) {\n        charPosSpan = this.#charPosSpan = new CharPositionSpan(this.source, {\n          start,\n          end,\n        });\n      } else {\n        charPosSpan = this.#charPosSpan = BROKEN;\n        return null;\n      }\n    }\n\n    return charPosSpan === BROKEN ? null : charPosSpan;\n  }\n}\n\nclass InvisibleSpan implements SpanData {\n  constructor(\n    readonly kind: InvisibleKind,\n    // whatever was provided, possibly broken\n    readonly loc: SourceLocation,\n    // if the span represents a synthetic string\n    readonly string: string | null = null\n  ) {}\n\n  serialize(): SerializedConcreteSourceSpan {\n    switch (this.kind) {\n      case BROKEN_KIND:\n      case NON_EXISTENT_KIND:\n        return this.kind;\n      case INTERNAL_SYNTHETIC_KIND:\n        return this.string || '';\n    }\n  }\n\n  wrap(): SourceSpan {\n    return new SourceSpan(this);\n  }\n\n  asString(): string {\n    return this.string || '';\n  }\n\n  locDidUpdate({ start, end }: { start?: SourcePosition; end?: SourcePosition }) {\n    if (start !== undefined) {\n      this.loc.start = start;\n    }\n\n    if (end !== undefined) {\n      this.loc.end = end;\n    }\n  }\n\n  getModule(): string {\n    // TODO: Make this reflect the actual module this span originated from\n    return 'an unknown module';\n  }\n\n  getStart(): AnyPosition {\n    return new InvisiblePosition(this.kind, this.loc.start);\n  }\n\n  getEnd(): AnyPosition {\n    return new InvisiblePosition(this.kind, this.loc.end);\n  }\n\n  toCharPosSpan(): this {\n    return this;\n  }\n\n  toHbsSpan(): null {\n    return null;\n  }\n\n  toHbsLoc(): SourceLocation {\n    return BROKEN_LOCATION;\n  }\n}\n\nexport const span: MatchFn<SourceSpan> = match((m) =>\n  m\n    .when(HBS_POSITION_KIND, HBS_POSITION_KIND, (left, right) =>\n      new HbsSpan(left.source, {\n        start: left,\n        end: right,\n      }).wrap()\n    )\n    .when(CHAR_OFFSET_KIND, CHAR_OFFSET_KIND, (left, right) =>\n      new CharPositionSpan(left.source, {\n        start: left,\n        end: right,\n      }).wrap()\n    )\n    .when(CHAR_OFFSET_KIND, HBS_POSITION_KIND, (left, right) => {\n      const rightCharPos = right.toCharPos();\n\n      if (rightCharPos === null) {\n        return new InvisibleSpan(BROKEN_KIND, BROKEN_LOCATION).wrap();\n      } else {\n        return span(left, rightCharPos);\n      }\n    })\n    .when(HBS_POSITION_KIND, CHAR_OFFSET_KIND, (left, right) => {\n      const leftCharPos = left.toCharPos();\n\n      if (leftCharPos === null) {\n        return new InvisibleSpan(BROKEN_KIND, BROKEN_LOCATION).wrap();\n      } else {\n        return span(leftCharPos, right);\n      }\n    })\n    .when(IsInvisible, MatchAny, (left) => new InvisibleSpan(left.kind, BROKEN_LOCATION).wrap())\n    .when(MatchAny, IsInvisible, (_, right) =>\n      new InvisibleSpan(right.kind, BROKEN_LOCATION).wrap()\n    )\n);\n\nexport type SerializedConcreteSourceSpan =\n  | /** collapsed */ number\n  | /** normal */ [start: number, size: number]\n  | /** synthetic */ string;\n\n// `string` includes NON_EXISTENT_KIND and BROKEN_KIND\nexport type SerializedSourceSpan = SerializedConcreteSourceSpan;\n","import type { SourcePosition } from '../location';\nimport type { Source } from '../source';\nimport type { BrokenKind, InternalSyntheticKind, NonExistentKind, OffsetKind } from './kinds';\nimport type { SourceSpan } from './span';\n\nimport { UNKNOWN_POSITION } from '../location';\nimport { BROKEN_KIND, CHAR_OFFSET_KIND, HBS_POSITION_KIND } from './kinds';\nimport { match, MatchAny } from './match';\nimport { span } from './span';\n\n/**\n * All positions have these details in common. Most notably, all three kinds of positions can\n * must be able to attempt to convert themselves into {@see CharPosition}.\n */\nexport interface PositionData {\n  readonly kind: OffsetKind;\n  toCharPos(): CharPosition | null;\n  toJSON(): SourcePosition;\n}\n\n/**\n * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It\n * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet\n * attempted (and therefore to cache the failure)\n */\nexport const BROKEN = 'BROKEN';\nexport type BROKEN = 'BROKEN';\n\nexport type AnyPosition = HbsPosition | CharPosition | InvisiblePosition;\n\n/**\n * A `SourceOffset` represents a single position in the source.\n *\n * There are three kinds of backing data for `SourceOffset` objects:\n *\n * - `CharPosition`, which contains a character offset into the raw source string\n * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be\n *   converted to a `CharPosition` on demand.\n * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})\n */\nexport class SourceOffset {\n  /**\n   * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted\n   * into a character offset on demand, which avoids unnecessarily computing the offset of every\n   * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.\n   */\n  static forHbsPos(source: Source, pos: SourcePosition): SourceOffset {\n    return new HbsPosition(source, pos, null).wrap();\n  }\n\n  /**\n   * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the\n   * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to\n   * any part of the source.\n   */\n  static broken(pos: SourcePosition = UNKNOWN_POSITION): SourceOffset {\n    return new InvisiblePosition(BROKEN_KIND, pos).wrap();\n  }\n\n  constructor(readonly data: PositionData & AnyPosition) {}\n\n  /**\n   * Get the character offset for this `SourceOffset`, if possible.\n   */\n  get offset(): number | null {\n    const charPos = this.data.toCharPos();\n    return charPos === null ? null : charPos.offset;\n  }\n\n  /**\n   * Compare this offset with another one.\n   *\n   * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are\n   * the same. This avoids computing offsets unnecessarily.\n   *\n   * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets\n   * are the same.\n   */\n  eql(right: SourceOffset): boolean {\n    return eql(this.data, right.data);\n  }\n\n  /**\n   * Create a span that starts from this source offset and ends with another source offset. Avoid\n   * computing character offsets if both `SourceOffset`s are still lazy.\n   */\n  until(other: SourceOffset): SourceSpan {\n    return span(this.data, other.data);\n  }\n\n  /**\n   * Create a `SourceOffset` by moving the character position represented by this source offset\n   * forward or backward (if `by` is negative), if possible.\n   *\n   * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.\n   *\n   * If the resulting character offset is less than 0 or greater than the size of the source, `move`\n   * returns a broken offset.\n   */\n  move(by: number): SourceOffset {\n    const charPos = this.data.toCharPos();\n\n    if (charPos === null) {\n      return SourceOffset.broken();\n    } else {\n      const result = charPos.offset + by;\n\n      if (charPos.source.validate(result)) {\n        return new CharPosition(charPos.source, result).wrap();\n      } else {\n        return SourceOffset.broken();\n      }\n    }\n  }\n\n  /**\n   * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid\n   * computing the character offset if it has not already been computed.\n   */\n  collapsed(): SourceSpan {\n    return span(this.data, this.data);\n  }\n\n  /**\n   * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with\n   * existing plugins.\n   */\n  toJSON(): SourcePosition {\n    return this.data.toJSON();\n  }\n}\n\nexport class CharPosition implements PositionData {\n  readonly kind = CHAR_OFFSET_KIND;\n\n  /** Computed from char offset */\n  _locPos: HbsPosition | BROKEN | null = null;\n\n  constructor(\n    readonly source: Source,\n    readonly charPos: number\n  ) {}\n\n  /**\n   * This is already a `CharPosition`.\n   *\n   * {@see HbsPosition} for the alternative.\n   */\n  toCharPos(): this {\n    return this;\n  }\n\n  /**\n   * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was\n   * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.\n   */\n  toJSON(): SourcePosition {\n    const hbs = this.toHbsPos();\n    return hbs === null ? UNKNOWN_POSITION : hbs.toJSON();\n  }\n\n  wrap(): SourceOffset {\n    return new SourceOffset(this);\n  }\n\n  /**\n   * A `CharPosition` always has an offset it can produce without any additional computation.\n   */\n  get offset(): number {\n    return this.charPos;\n  }\n\n  /**\n   * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once\n   * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and\n   * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so\n   * computing the `HbsPosition` should be a one-time operation.\n   */\n  toHbsPos(): HbsPosition | null {\n    let locPos = this._locPos;\n\n    if (locPos === null) {\n      const hbsPos = this.source.hbsPosFor(this.charPos);\n\n      if (hbsPos === null) {\n        this._locPos = locPos = BROKEN;\n      } else {\n        this._locPos = locPos = new HbsPosition(this.source, hbsPos, this.charPos);\n      }\n    }\n\n    return locPos === BROKEN ? null : locPos;\n  }\n}\n\nexport class HbsPosition implements PositionData {\n  readonly kind = HBS_POSITION_KIND;\n\n  _charPos: CharPosition | BROKEN | null;\n\n  constructor(\n    readonly source: Source,\n    readonly hbsPos: SourcePosition,\n    charPos: number | null = null\n  ) {\n    this._charPos = charPos === null ? null : new CharPosition(source, charPos);\n  }\n\n  /**\n   * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has\n   * computed its `CharPosition`, it will not need to do compute it again, and the same\n   * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the\n   * `CharPosition` should be a one-time operation.\n   */\n  toCharPos(): CharPosition | null {\n    let charPos = this._charPos;\n\n    if (charPos === null) {\n      const charPosNumber = this.source.charPosFor(this.hbsPos);\n\n      if (charPosNumber === null) {\n        this._charPos = charPos = BROKEN;\n      } else {\n        this._charPos = charPos = new CharPosition(this.source, charPosNumber);\n      }\n    }\n\n    return charPos === BROKEN ? null : charPos;\n  }\n\n  /**\n   * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation\n   * does not need to compute anything.\n   */\n  toJSON(): SourcePosition {\n    return this.hbsPos;\n  }\n\n  wrap(): SourceOffset {\n    return new SourceOffset(this);\n  }\n\n  /**\n   * This is already an `HbsPosition`.\n   *\n   * {@see CharPosition} for the alternative.\n   */\n  toHbsPos(): this {\n    return this;\n  }\n}\n\nexport class InvisiblePosition implements PositionData {\n  constructor(\n    readonly kind: BrokenKind | InternalSyntheticKind | NonExistentKind,\n    // whatever was provided, possibly broken\n    readonly pos: SourcePosition\n  ) {}\n\n  /**\n   * A broken position cannot be turned into a {@see CharacterPosition}.\n   */\n  toCharPos(): null {\n    return null;\n  }\n\n  /**\n   * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was\n   * originally identified as broken, non-existent or synthetic.\n   *\n   * If an `InvisiblePosition` never had an source offset at all, this method returns\n   * {@see UNKNOWN_POSITION} for compatibility.\n   */\n  toJSON(): SourcePosition {\n    return this.pos;\n  }\n\n  wrap(): SourceOffset {\n    return new SourceOffset(this);\n  }\n\n  get offset(): null {\n    return null;\n  }\n}\n\n/**\n * Compare two {@see AnyPosition} and determine whether they are equal.\n *\n * @see {SourceOffset#eql}\n */\nconst eql = match<boolean>((m) =>\n  m\n    .when(\n      HBS_POSITION_KIND,\n      HBS_POSITION_KIND,\n      ({ hbsPos: left }, { hbsPos: right }) =>\n        left.column === right.column && left.line === right.line\n    )\n    .when(\n      CHAR_OFFSET_KIND,\n      CHAR_OFFSET_KIND,\n      ({ charPos: left }, { charPos: right }) => left === right\n    )\n    .when(\n      CHAR_OFFSET_KIND,\n      HBS_POSITION_KIND,\n      ({ offset: left }, right) => left === right.toCharPos()?.offset\n    )\n    .when(\n      HBS_POSITION_KIND,\n      CHAR_OFFSET_KIND,\n      (left, { offset: right }) => left.toCharPos()?.offset === right\n    )\n    .when(MatchAny, MatchAny, () => false)\n);\n","import type { Nullable } from '@glimmer/interfaces';\nimport { localAssert, setLocalDebugType } from '@glimmer/debug-util';\n\nimport type { PrecompileOptions } from '../parser/tokenizer-event-handlers';\nimport type { SourceLocation, SourcePosition } from './location';\n\nimport { SourceOffset, SourceSpan } from './span';\n\nexport class Source {\n  static from(source: string, options: PrecompileOptions = {}): Source {\n    return new Source(source, options.meta?.moduleName);\n  }\n\n  constructor(\n    readonly source: string,\n    readonly module = 'an unknown module'\n  ) {\n    setLocalDebugType('syntax:source', this);\n  }\n\n  /**\n   * Validate that the character offset represents a position in the source string.\n   */\n  validate(offset: number): boolean {\n    return offset >= 0 && offset <= this.source.length;\n  }\n\n  slice(start: number, end: number): string {\n    return this.source.slice(start, end);\n  }\n\n  offsetFor(line: number, column: number): SourceOffset {\n    return SourceOffset.forHbsPos(this, { line, column });\n  }\n\n  spanFor({ start, end }: Readonly<SourceLocation>): SourceSpan {\n    return SourceSpan.forHbsLoc(this, {\n      start: { line: start.line, column: start.column },\n      end: { line: end.line, column: end.column },\n    });\n  }\n\n  hbsPosFor(offset: number): Nullable<SourcePosition> {\n    let seenLines = 0;\n    let seenChars = 0;\n\n    if (offset > this.source.length) {\n      return null;\n    }\n\n    while (true) {\n      let nextLine = this.source.indexOf('\\n', seenChars);\n\n      if (offset <= nextLine || nextLine === -1) {\n        return {\n          line: seenLines + 1,\n          column: offset - seenChars,\n        };\n      } else {\n        seenLines += 1;\n        seenChars = nextLine + 1;\n      }\n    }\n  }\n\n  charPosFor(position: SourcePosition): number | null {\n    let { line, column } = position;\n    let sourceString = this.source;\n    let sourceLength = sourceString.length;\n    let seenLines = 0;\n    let seenChars = 0;\n\n    while (seenChars < sourceLength) {\n      let nextLine = this.source.indexOf('\\n', seenChars);\n      if (nextLine === -1) nextLine = this.source.length;\n\n      if (seenLines === line - 1) {\n        if (seenChars + column > nextLine) return nextLine;\n\n        if (import.meta.env.DEV) {\n          let roundTrip = this.hbsPosFor(seenChars + column);\n          localAssert(roundTrip !== null, `the returned offset failed to round-trip`);\n          localAssert(\n            roundTrip.line === line,\n            `the round-tripped line didn't match the original line`\n          );\n          localAssert(\n            roundTrip.column === column,\n            `the round-tripped column didn't match the original column`\n          );\n        }\n\n        return seenChars + column;\n      } else if (nextLine === -1) {\n        return 0;\n      } else {\n        seenLines += 1;\n        seenChars = nextLine + 1;\n      }\n    }\n\n    return sourceLength;\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { getFirst, getLast, isPresentArray } from '@glimmer/debug-util';\n\nimport type { LocatedWithOptionalSpan, LocatedWithSpan } from './location';\nimport type { SourceOffset } from './span';\n\nimport { SourceSpan } from './span';\n\nexport type HasSpan = SourceSpan | LocatedWithSpan | PresentArray<LocatedWithSpan>;\nexport type MaybeHasSpan = SourceSpan | LocatedWithOptionalSpan | LocatedWithOptionalSpan[] | null;\n\nexport type ToSourceOffset = number | SourceOffset;\n\nexport class SpanList {\n  static range(span: PresentArray<HasSourceSpan>): SourceSpan;\n  static range(span: HasSourceSpan[], fallback: SourceSpan): SourceSpan;\n  static range(span: HasSourceSpan[], fallback: SourceSpan = SourceSpan.NON_EXISTENT): SourceSpan {\n    return new SpanList(span.map(loc)).getRangeOffset(fallback);\n  }\n\n  _span: SourceSpan[];\n\n  constructor(span: SourceSpan[] = []) {\n    this._span = span;\n  }\n\n  add(offset: SourceSpan): void {\n    this._span.push(offset);\n  }\n\n  getRangeOffset(fallback: SourceSpan): SourceSpan {\n    if (isPresentArray(this._span)) {\n      let first = getFirst(this._span);\n      let last = getLast(this._span);\n      return first.extend(last);\n    } else {\n      return fallback;\n    }\n  }\n}\n\nexport type HasSourceSpan = { loc: SourceSpan } | SourceSpan | [HasSourceSpan, ...HasSourceSpan[]];\n\nexport function loc(span: HasSourceSpan): SourceSpan {\n  if (Array.isArray(span)) {\n    let first = getFirst(span);\n    let last = getLast(span);\n    return loc(first).extend(loc(last));\n  } else if (span instanceof SourceSpan) {\n    return span;\n  } else {\n    return span.loc;\n  }\n}\n\nexport type MaybeHasSourceSpan = { loc: SourceSpan } | SourceSpan | MaybeHasSourceSpan[];\n\nexport function hasSpan(span: MaybeHasSourceSpan): span is HasSourceSpan {\n  if (Array.isArray(span) && span.length === 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function maybeLoc(location: MaybeHasSourceSpan, fallback: SourceSpan): SourceSpan {\n  if (hasSpan(location)) {\n    return loc(location);\n  } else {\n    return fallback;\n  }\n}\n","import type * as src from './source/api';\n\nexport interface GlimmerSyntaxError extends Error {\n  location: src.SourceSpan | null;\n  code: string | null;\n}\n\nexport function generateSyntaxError(message: string, location: src.SourceSpan): GlimmerSyntaxError {\n  let { module, loc } = location;\n  let { line, column } = loc.start;\n\n  let code = location.asString();\n  let quotedCode = code ? `\\n\\n|\\n|  ${code.split('\\n').join('\\n|  ')}\\n|\\n\\n` : '';\n\n  let error = new Error(\n    `${message}: ${quotedCode}(error occurred in '${module}' @ line ${line} : column ${column})`\n  ) as GlimmerSyntaxError;\n\n  error.name = 'SyntaxError';\n  error.location = location;\n  error.code = code;\n\n  return error;\n}\n","import type * as ASTv1 from './api';\n\n// ensure stays in sync with typing\n// ParentNode and ChildKey types are derived from VisitorKeysMap\nconst visitorKeys = {\n  Template: ['body'],\n  Block: ['body'],\n\n  MustacheStatement: ['path', 'params', 'hash'],\n  BlockStatement: ['path', 'params', 'hash', 'program', 'inverse'],\n  ElementModifierStatement: ['path', 'params', 'hash'],\n  CommentStatement: [],\n  MustacheCommentStatement: [],\n  ElementNode: ['attributes', 'modifiers', 'children', 'comments'],\n  AttrNode: ['value'],\n  TextNode: [],\n\n  ConcatStatement: ['parts'],\n  SubExpression: ['path', 'params', 'hash'],\n  PathExpression: [],\n\n  StringLiteral: [],\n  BooleanLiteral: [],\n  NumberLiteral: [],\n  NullLiteral: [],\n  UndefinedLiteral: [],\n\n  Hash: ['pairs'],\n  HashPair: ['value'],\n} as const;\n\ntype VisitorKeysMap = typeof visitorKeys;\n\nexport type VisitorKeys = { [P in keyof VisitorKeysMap]: VisitorKeysMap[P][number] };\nexport type VisitorKey<N extends ASTv1.Node> = VisitorKeys[N['type']] & keyof N;\n\nexport default visitorKeys;\n","import type { Nullable } from '@glimmer/interfaces';\n\nimport type * as ASTv1 from '../v1/api';\n\nexport interface TraversalError extends Error {\n  constructor: TraversalErrorConstructor;\n  key: string;\n  node: ASTv1.Node;\n  parent: Nullable<ASTv1.Node>;\n  stack?: string;\n}\n\nexport interface TraversalErrorConstructor {\n  new (\n    message: string,\n    node: ASTv1.Node,\n    parent: Nullable<ASTv1.Node>,\n    key: string\n  ): TraversalError;\n  readonly prototype: TraversalError;\n}\n\nconst TraversalError: TraversalErrorConstructor = (function () {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  TraversalError.prototype = Object.create(Error.prototype);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  TraversalError.prototype.constructor = TraversalError;\n\n  function TraversalError(\n    this: TraversalError,\n    message: string,\n    node: ASTv1.Node,\n    parent: Nullable<ASTv1.Node>,\n    key: string\n  ) {\n    let error = Error.call(this, message);\n\n    this.key = key;\n    this.message = message;\n    this.node = node;\n    this.parent = parent;\n\n    if (error.stack) {\n      this.stack = error.stack;\n    }\n  }\n\n  return TraversalError as unknown as TraversalErrorConstructor;\n})();\n\nexport default TraversalError;\n\nexport function cannotRemoveNode(\n  node: ASTv1.Node,\n  parent: ASTv1.Node,\n  key: string\n): TraversalError {\n  return new TraversalError(\n    'Cannot remove a node unless it is part of an array',\n    node,\n    parent,\n    key\n  );\n}\n\nexport function cannotReplaceNode(\n  node: ASTv1.Node,\n  parent: ASTv1.Node,\n  key: string\n): TraversalError {\n  return new TraversalError(\n    'Cannot replace a node with multiple nodes unless it is part of an array',\n    node,\n    parent,\n    key\n  );\n}\n\nexport function cannotReplaceOrRemoveInKeyHandlerYet(\n  node: ASTv1.Node,\n  key: string\n): TraversalError {\n  return new TraversalError(\n    'Replacing and removing in key handlers is not yet supported.',\n    node,\n    null,\n    key\n  );\n}\n","import type * as ASTv1 from '../v1/api';\n\nexport default class WalkerPath<N extends ASTv1.Node> {\n  node: N;\n  parent: WalkerPath<ASTv1.Node> | null;\n  parentKey: string | null;\n\n  constructor(\n    node: N,\n    parent: WalkerPath<ASTv1.Node> | null = null,\n    parentKey: string | null = null\n  ) {\n    this.node = node;\n    this.parent = parent;\n    this.parentKey = parentKey;\n  }\n\n  get parentNode(): ASTv1.Node | null {\n    return this.parent ? this.parent.node : null;\n  }\n\n  parents(): Iterable<WalkerPath<ASTv1.Node> | null> {\n    return {\n      [Symbol.iterator]: () => {\n        return new PathParentsIterator(this);\n      },\n    };\n  }\n}\n\nclass PathParentsIterator implements Iterator<WalkerPath<ASTv1.Node> | null> {\n  path: WalkerPath<ASTv1.Node>;\n\n  constructor(path: WalkerPath<ASTv1.Node>) {\n    this.path = path;\n  }\n\n  next() {\n    if (this.path.parent) {\n      this.path = this.path.parent;\n      return { done: false, value: this.path };\n    } else {\n      return { done: true, value: null };\n    }\n  }\n}\n","import { deprecate, unwrap } from '@glimmer/debug-util';\n\nimport type * as ASTv1 from '../v1/api';\nimport type { VisitorKey, VisitorKeys } from '../v1/visitor-keys';\nimport type { KeyHandler, KeyTraversal, NodeHandler, NodeTraversal, NodeVisitor } from './visitor';\n\nimport visitorKeys from '../v1/visitor-keys';\nimport {\n  cannotRemoveNode,\n  cannotReplaceNode,\n  cannotReplaceOrRemoveInKeyHandlerYet,\n} from './errors';\nimport WalkerPath from './path';\n\nfunction getEnterFunction<N extends ASTv1.Node>(\n  handler: NodeTraversal<N>\n): NodeHandler<N> | undefined;\nfunction getEnterFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: KeyTraversal<N, K>\n): KeyHandler<N, K> | undefined;\nfunction getEnterFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: NodeTraversal<N> | KeyTraversal<N, K>\n): NodeHandler<N> | KeyHandler<N, K> | undefined {\n  if (typeof handler === 'function') {\n    return handler;\n  } else {\n    return handler.enter as NodeHandler<N> | KeyHandler<N, K>;\n  }\n}\n\nfunction getExitFunction<N extends ASTv1.Node>(\n  handler: NodeTraversal<N>\n): NodeHandler<N> | undefined;\nfunction getExitFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: KeyTraversal<N, K>\n): KeyHandler<N, K> | undefined;\nfunction getExitFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: NodeTraversal<N> | KeyTraversal<N, K>\n): NodeHandler<N> | KeyHandler<N, K> | undefined {\n  if (typeof handler === 'function') {\n    return undefined;\n  } else {\n    return handler.exit as NodeHandler<N> | KeyHandler<N, K>;\n  }\n}\n\nfunction getKeyHandler<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: NodeTraversal<N>,\n  key: K\n): KeyTraversal<N, K> | KeyTraversal<N, VisitorKey<N>> | undefined {\n  let keyVisitor = typeof handler !== 'function' ? handler.keys : undefined;\n  if (keyVisitor === undefined) return;\n\n  let keyHandler = keyVisitor[key];\n  if (keyHandler !== undefined) {\n    return keyHandler as KeyTraversal<N, K>;\n  }\n  return keyVisitor.All;\n}\n\nfunction getNodeHandler<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  nodeType: N['type']\n): NodeTraversal<N> | undefined;\nfunction getNodeHandler(\n  visitor: NodeVisitor,\n  nodeType: 'All'\n): NodeTraversal<ASTv1.Node> | undefined;\nfunction getNodeHandler<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  nodeType: N['type']\n): NodeTraversal<ASTv1.Node> | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-deprecated\n  if (visitor.Program) {\n    if (\n      (nodeType === 'Template' && !visitor.Template) ||\n      (nodeType === 'Block' && !visitor.Block)\n    ) {\n      deprecate(\n        `The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${nodeType}') `\n      );\n\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      return visitor.Program as NodeTraversal<ASTv1.Node>;\n    }\n  }\n\n  let handler = visitor[nodeType];\n  if (handler !== undefined) {\n    return handler as unknown as NodeTraversal<ASTv1.Node>;\n  }\n  return visitor.All;\n}\n\nfunction visitNode<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  path: WalkerPath<N>\n): ASTv1.Node | ASTv1.Node[] | undefined | null | void {\n  let { node, parent, parentKey } = path;\n\n  let handler: NodeTraversal<N> | undefined = getNodeHandler(visitor, node.type);\n  let enter: NodeHandler<N> | undefined;\n  let exit: NodeHandler<N> | undefined;\n\n  if (handler !== undefined) {\n    enter = getEnterFunction(handler);\n    exit = getExitFunction(handler);\n  }\n\n  let result: ASTv1.Node | ASTv1.Node[] | undefined | null | void;\n  if (enter !== undefined) {\n    result = enter(node, path);\n  }\n\n  if (result !== undefined && result !== null) {\n    if (JSON.stringify(node) === JSON.stringify(result)) {\n      result = undefined;\n    } else if (Array.isArray(result)) {\n      visitArray(visitor, result, parent, parentKey);\n      return result;\n    } else {\n      let path = new WalkerPath(result, parent, parentKey);\n      return visitNode(visitor, path) || result;\n    }\n  }\n\n  if (result === undefined) {\n    let keys = visitorKeys[node.type];\n\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i] as VisitorKeys[N['type']] & keyof N;\n      // we know if it has child keys we can widen to a ParentNode\n      visitKey(visitor, handler, path, key);\n    }\n\n    if (exit !== undefined) {\n      result = exit(node, path);\n    }\n  }\n\n  return result;\n}\n\nfunction get<N extends ASTv1.Node>(\n  node: N,\n  key: VisitorKeys[N['type']] & keyof N\n): ASTv1.Node | ASTv1.Node[] | undefined {\n  return node[key] as unknown as ASTv1.Node | ASTv1.Node[] | undefined;\n}\n\nfunction set<N extends ASTv1.Node, K extends keyof N>(node: N, key: K, value: N[K]): void {\n  node[key] = value;\n}\n\nfunction visitKey<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  handler: NodeTraversal<N> | undefined,\n  path: WalkerPath<N>,\n  key: VisitorKeys[N['type']] & keyof N\n) {\n  let { node } = path;\n\n  let value = get(node, key);\n  if (!value) {\n    return;\n  }\n\n  let keyEnter: KeyHandler<N, VisitorKeys[N['type']] & keyof N> | undefined;\n  let keyExit: KeyHandler<N, VisitorKeys[N['type']] & keyof N> | undefined;\n\n  if (handler !== undefined) {\n    let keyHandler = getKeyHandler(handler, key);\n    if (keyHandler !== undefined) {\n      keyEnter = getEnterFunction(keyHandler);\n      keyExit = getExitFunction(keyHandler);\n    }\n  }\n\n  if (keyEnter !== undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression -- JS API\n    if (keyEnter(node, key) !== undefined) {\n      throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);\n    }\n  }\n\n  if (Array.isArray(value)) {\n    visitArray(visitor, value, path, key);\n  } else {\n    let keyPath = new WalkerPath(value, path, key);\n    let result = visitNode(visitor, keyPath);\n    if (result !== undefined) {\n      // TODO: dynamically check the results by having a table of\n      // expected node types in value space, not just type space\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n      assignKey(node, key, value, result as any);\n    }\n  }\n\n  if (keyExit !== undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression -- JS API\n    if (keyExit(node, key) !== undefined) {\n      throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);\n    }\n  }\n}\n\nfunction visitArray(\n  visitor: NodeVisitor,\n  array: ASTv1.Node[],\n  parent: WalkerPath<ASTv1.Node> | null,\n  parentKey: string | null\n) {\n  for (let i = 0; i < array.length; i++) {\n    let node = unwrap(array[i]);\n    let path = new WalkerPath(node, parent, parentKey);\n    let result = visitNode(visitor, path);\n    if (result !== undefined) {\n      i += spliceArray(array, i, result) - 1;\n    }\n  }\n}\n\nfunction assignKey<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  node: N,\n  key: K,\n  value: ASTv1.Node,\n  result: N[K] | [N[K]] | null\n) {\n  if (result === null) {\n    throw cannotRemoveNode(value, node, key);\n  } else if (Array.isArray(result)) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (result.length === 1) {\n      set(node, key, result[0]);\n    } else {\n      if (result.length === 0) {\n        throw cannotRemoveNode(value, node, key);\n      } else {\n        throw cannotReplaceNode(value, node, key);\n      }\n    }\n  } else {\n    set(node, key, result);\n  }\n}\n\nfunction spliceArray(array: ASTv1.Node[], index: number, result: ASTv1.Node | ASTv1.Node[] | null) {\n  if (result === null) {\n    array.splice(index, 1);\n    return 0;\n  } else if (Array.isArray(result)) {\n    array.splice(index, 1, ...result);\n    return result.length;\n  } else {\n    array.splice(index, 1, result);\n    return 1;\n  }\n}\n\nexport default function traverse(node: ASTv1.Node, visitor: NodeVisitor): void {\n  let path = new WalkerPath(node);\n  visitNode(visitor, path);\n}\n","import type { Nullable } from '@glimmer/interfaces';\n\nimport type * as ASTv1 from '../v1/api';\n\nexport type NodeCallback<N extends ASTv1.Node> = (node: N, walker: Walker) => void;\n\nexport default class Walker {\n  public stack: unknown[] = [];\n  constructor(public order?: unknown) {}\n\n  visit<N extends ASTv1.Node>(node: Nullable<N>, visitor: NodeCallback<N>): void {\n    if (!node) {\n      return;\n    }\n\n    this.stack.push(node);\n\n    if (this.order === 'post') {\n      this.children(node, visitor);\n      visitor(node, this);\n    } else {\n      visitor(node, this);\n      this.children(node, visitor);\n    }\n\n    this.stack.pop();\n  }\n\n  children<N extends ASTv1.Node>(\n    node: N & ASTv1.Node,\n    callback: NodeCallback<N & ASTv1.Node>\n  ): void {\n    switch (node.type) {\n      case 'Block':\n      case 'Template':\n        walkBody(this, node.body, callback);\n        return;\n      case 'ElementNode':\n        walkBody(this, node.children, callback);\n        return;\n      case 'BlockStatement':\n        this.visit(node.program, callback);\n        this.visit(node.inverse || null, callback);\n        return;\n      default:\n        return;\n    }\n  }\n}\n\nfunction walkBody(\n  walker: Walker,\n  body: ASTv1.Statement[],\n  callback: NodeCallback<ASTv1.Statement>\n) {\n  for (const child of body) {\n    walker.visit(child, callback);\n  }\n}\n","import type * as ASTv1 from './v1/api';\nimport type * as HBS from './v1/handlebars-ast';\n\nexport function childrenFor(\n  node: ASTv1.Block | ASTv1.Template | ASTv1.ElementNode\n): ASTv1.TopLevelStatement[] {\n  switch (node.type) {\n    case 'Block':\n    case 'Template':\n      return node.body;\n    case 'ElementNode':\n      return node.children;\n  }\n}\n\nexport function appendChild(\n  parent: ASTv1.Block | ASTv1.Template | ASTv1.ElementNode,\n  node: ASTv1.Statement\n): void {\n  childrenFor(parent).push(node);\n}\n\nexport function isHBSLiteral(path: HBS.Expression): path is HBS.Literal;\nexport function isHBSLiteral(path: ASTv1.Expression): path is ASTv1.Literal;\nexport function isHBSLiteral(\n  path: HBS.Expression | ASTv1.Expression\n): path is HBS.Literal | ASTv1.Literal {\n  return (\n    path.type === 'StringLiteral' ||\n    path.type === 'BooleanLiteral' ||\n    path.type === 'NumberLiteral' ||\n    path.type === 'NullLiteral' ||\n    path.type === 'UndefinedLiteral'\n  );\n}\n\nexport function printLiteral(literal: ASTv1.Literal): string {\n  if (literal.type === 'UndefinedLiteral') {\n    return 'undefined';\n  } else {\n    return JSON.stringify(literal.value);\n  }\n}\n\nexport function isUpperCase(tag: string): boolean {\n  return tag[0] === tag[0]?.toUpperCase() && tag[0] !== tag[0]?.toLowerCase();\n}\n\nexport function isLowerCase(tag: string): boolean {\n  return tag[0] === tag[0]?.toLowerCase() && tag[0] !== tag[0]?.toUpperCase();\n}\n","import type { Dict, Maybe, Nullable } from '@glimmer/interfaces';\nimport { asPresentArray, deprecate, isPresentArray, localAssert } from '@glimmer/debug-util';\n\nimport type { SourceLocation, SourcePosition } from '../source/location';\nimport type * as ASTv1 from './api';\n\nimport { isVoidTag } from '../generation/printer';\nimport { SYNTHETIC_LOCATION } from '../source/location';\nimport { Source } from '../source/source';\nimport { SourceSpan } from '../source/span';\nimport b from './parser-builders';\n\nlet _SOURCE: Source | undefined;\n\nfunction SOURCE(): Source {\n  if (!_SOURCE) {\n    _SOURCE = new Source('', '(synthetic)');\n  }\n\n  return _SOURCE;\n}\n\n// const SOURCE = new Source('', '(tests)');\n\n// Statements\n\nexport type BuilderHead = string | ASTv1.CallableExpression;\nexport type TagDescriptor =\n  | string\n  | ASTv1.PathExpression\n  | { path: ASTv1.PathExpression; selfClosing?: boolean }\n  | { name: string; selfClosing?: boolean };\n\nfunction buildMustache(\n  path: BuilderHead | ASTv1.Literal,\n  params: ASTv1.Expression[] = [],\n  hash: ASTv1.Hash = buildHash([]),\n  trusting = false,\n  loc?: SourceLocation,\n  strip?: ASTv1.StripFlags\n): ASTv1.MustacheStatement {\n  return b.mustache({\n    path: buildPath(path),\n    params,\n    hash,\n    trusting,\n    strip,\n    loc: buildLoc(loc || null),\n  });\n}\n\ntype PossiblyDeprecatedBlock = ASTv1.Block | ASTv1.Template;\n\nfunction buildBlock(\n  path: BuilderHead,\n  params: Nullable<ASTv1.Expression[]>,\n  hash: Nullable<ASTv1.Hash>,\n  _defaultBlock: PossiblyDeprecatedBlock,\n  _elseBlock: Nullable<PossiblyDeprecatedBlock> = null,\n  loc?: SourceLocation,\n  openStrip?: ASTv1.StripFlags,\n  inverseStrip?: ASTv1.StripFlags,\n  closeStrip?: ASTv1.StripFlags\n): ASTv1.BlockStatement {\n  let defaultBlock: ASTv1.Block;\n  let elseBlock: Nullable<ASTv1.Block> = null;\n\n  if (_defaultBlock.type === 'Template') {\n    deprecate(`b.program is deprecated. Use b.blockItself instead.`);\n    defaultBlock = b.blockItself({\n      params: buildBlockParams(_defaultBlock.blockParams),\n      body: _defaultBlock.body,\n      loc: _defaultBlock.loc,\n    });\n  } else {\n    defaultBlock = _defaultBlock;\n  }\n\n  if (_elseBlock?.type === 'Template') {\n    deprecate(`b.program is deprecated. Use b.blockItself instead.`);\n    localAssert(_elseBlock.blockParams.length === 0, '{{else}} block cannot have block params');\n\n    elseBlock = b.blockItself({\n      params: [],\n      body: _elseBlock.body,\n      loc: _elseBlock.loc,\n    });\n  } else {\n    elseBlock = _elseBlock;\n  }\n\n  return b.block({\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    defaultBlock,\n    elseBlock,\n    loc: buildLoc(loc || null),\n    openStrip,\n    inverseStrip,\n    closeStrip,\n  });\n}\n\nfunction buildElementModifier(\n  path: BuilderHead,\n  params?: ASTv1.Expression[],\n  hash?: ASTv1.Hash,\n  loc?: Nullable<SourceLocation>\n): ASTv1.ElementModifierStatement {\n  return b.elementModifier({\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement {\n  return b.comment({\n    value: value,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement {\n  return b.mustacheComment({\n    value: value,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildConcat(\n  parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[],\n  loc?: SourceLocation\n): ASTv1.ConcatStatement {\n  if (!isPresentArray(parts)) {\n    throw new Error(`b.concat requires at least one part`);\n  }\n\n  return b.concat({\n    parts,\n    loc: buildLoc(loc || null),\n  });\n}\n\n// Nodes\n\nexport type ElementParts =\n  | ['attrs', ...AttrSexp[]]\n  | ['modifiers', ...ModifierSexp[]]\n  | ['body', ...ASTv1.Statement[]]\n  | ['comments', ...ElementComment[]]\n  | ['as', ...string[]]\n  | ['loc', SourceLocation];\n\nexport type PathSexp = string | ['path', string, LocSexp?];\n\nexport type ModifierSexp =\n  | string\n  | [PathSexp, LocSexp?]\n  | [PathSexp, ASTv1.Expression[], LocSexp?]\n  | [PathSexp, ASTv1.Expression[], Dict<ASTv1.Expression>, LocSexp?];\n\nexport type AttrSexp = [string, ASTv1.AttrNode['value'] | string, LocSexp?];\n\nexport type LocSexp = ['loc', SourceLocation];\n\nexport type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;\n\nexport type SexpValue =\n  | string\n  | ASTv1.Expression[]\n  | Dict<ASTv1.Expression>\n  | LocSexp\n  | PathSexp\n  | undefined;\n\nexport interface BuildElementOptions {\n  attrs?: ASTv1.AttrNode[];\n  modifiers?: ASTv1.ElementModifierStatement[];\n  children?: ASTv1.Statement[];\n  comments?: ASTv1.MustacheCommentStatement[];\n  blockParams?: ASTv1.VarHead[] | string[];\n  openTag?: SourceLocation;\n  closeTag?: Maybe<SourceLocation>;\n  loc?: SourceLocation;\n}\n\nfunction buildElement(tag: TagDescriptor, options: BuildElementOptions = {}): ASTv1.ElementNode {\n  let {\n    attrs,\n    blockParams,\n    modifiers,\n    comments,\n    children,\n    openTag,\n    closeTag: _closeTag,\n    loc,\n  } = options;\n\n  // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST\n  let path: ASTv1.PathExpression;\n  let selfClosing: boolean | undefined;\n\n  if (typeof tag === 'string') {\n    if (tag.endsWith('/')) {\n      path = buildPath(tag.slice(0, -1));\n      selfClosing = true;\n    } else {\n      path = buildPath(tag);\n    }\n  } else if ('type' in tag) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- supports JS users\n    localAssert(tag.type === 'PathExpression', `Invalid tag type ${tag.type}`);\n    path = tag;\n  } else if ('path' in tag) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- supports JS users\n    localAssert(tag.path.type === 'PathExpression', `Invalid tag type ${tag.path.type}`);\n    path = tag.path;\n    selfClosing = tag.selfClosing;\n  } else {\n    path = buildPath(tag.name);\n    selfClosing = tag.selfClosing;\n  }\n\n  if (selfClosing) {\n    localAssert(\n      _closeTag === null || _closeTag === undefined,\n      'Cannot build a self-closing tag with a closeTag source location'\n    );\n  }\n\n  let params = blockParams?.map((param) => {\n    if (typeof param === 'string') {\n      return buildVar(param);\n    } else {\n      return param;\n    }\n  });\n\n  let closeTag: Nullable<SourceSpan> = null;\n\n  if (_closeTag) {\n    closeTag = buildLoc(_closeTag);\n  } else if (_closeTag === undefined) {\n    closeTag = selfClosing || isVoidTag(path.original) ? null : buildLoc(null);\n  }\n\n  return b.element({\n    path,\n    selfClosing: selfClosing || false,\n    attributes: attrs || [],\n    params: params || [],\n    modifiers: modifiers || [],\n    comments: comments || [],\n    children: children || [],\n    openTag: buildLoc(openTag || null),\n    closeTag,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildAttr(name: string, value: ASTv1.AttrValue, loc?: SourceLocation): ASTv1.AttrNode {\n  return b.attr({\n    name: name,\n    value: value,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildText(chars = '', loc?: SourceLocation): ASTv1.TextNode {\n  return b.text({\n    chars,\n    loc: buildLoc(loc || null),\n  });\n}\n\n// Expressions\n\nfunction buildSexpr(\n  path: BuilderHead,\n  params: ASTv1.Expression[] = [],\n  hash: ASTv1.Hash = buildHash([]),\n  loc?: SourceLocation\n): ASTv1.SubExpression {\n  return b.sexpr({\n    path: buildPath(path),\n    params,\n    hash,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildHead(original: string, loc?: SourceLocation): ASTv1.PathExpression {\n  let [head, ...tail] = asPresentArray(original.split('.'));\n  let headNode = b.head({ original: head, loc: buildLoc(loc || null) });\n  return b.path({ head: headNode, tail, loc: buildLoc(loc || null) });\n}\n\nfunction buildThis(loc?: SourceLocation): ASTv1.ThisHead {\n  return b.this({ loc: buildLoc(loc || null) });\n}\n\nfunction buildAtName(name: string, loc?: SourceLocation): ASTv1.AtHead {\n  return b.atName({ name, loc: buildLoc(loc || null) });\n}\n\nfunction buildVar(name: string, loc?: SourceLocation): ASTv1.VarHead {\n  return b.var({ name, loc: buildLoc(loc || null) });\n}\n\nfunction buildHeadFromString(original: string, loc?: SourceLocation): ASTv1.PathHead {\n  return b.head({ original, loc: buildLoc(loc || null) });\n}\n\nfunction buildCleanPath(\n  head: ASTv1.PathHead,\n  tail: string[] = [],\n  loc?: SourceLocation\n): ASTv1.PathExpression {\n  return b.path({ head, tail, loc: buildLoc(loc || null) });\n}\n\nfunction buildPath(\n  path: ASTv1.PathExpression | string | { head: string; tail: string[] },\n  loc?: SourceLocation\n): ASTv1.PathExpression;\nfunction buildPath(path: BuilderHead, loc?: SourceLocation): ASTv1.CallableExpression;\nfunction buildPath(\n  path: BuilderHead | ASTv1.Literal | ASTv1.Expression,\n  loc?: SourceLocation\n): ASTv1.Expression;\nfunction buildPath(\n  path: BuilderHead | ASTv1.Expression | { head: string; tail: string[] },\n  loc?: SourceLocation\n): ASTv1.Expression {\n  let span = buildLoc(loc || null);\n\n  if (typeof path !== 'string') {\n    if ('type' in path) {\n      return path;\n    } else {\n      localAssert(\n        path.head.indexOf('.') === -1,\n        `builder.path({ head, tail }) should not be called with a head with dots in it`\n      );\n\n      let { head, tail } = path;\n\n      return b.path({\n        head: b.head({ original: head, loc: span.sliceStartChars({ chars: head.length }) }),\n        tail,\n        loc: buildLoc(loc || null),\n      });\n    }\n  }\n\n  let { head, tail } = buildHead(path, span);\n\n  return b.path({ head, tail, loc: span });\n}\n\nfunction buildLiteral<T extends ASTv1.Literal>(\n  type: T['type'],\n  value: T['value'],\n  loc?: SourceLocation\n): T {\n  return b.literal({\n    type,\n    value,\n    loc: buildLoc(loc || null),\n  });\n}\n\n// Miscellaneous\n\nfunction buildHash(pairs: ASTv1.HashPair[] = [], loc?: SourceLocation): ASTv1.Hash {\n  return b.hash({\n    pairs,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair {\n  return b.pair({\n    key,\n    value,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildProgram(\n  body?: ASTv1.Statement[],\n  blockParams?: string[],\n  loc?: SourceLocation\n): ASTv1.Template | ASTv1.Block {\n  deprecate(`b.program is deprecated. Use b.template or b.blockItself instead.`);\n\n  if (blockParams && blockParams.length) {\n    return buildBlockItself(body, blockParams, false, loc);\n  } else {\n    return buildTemplate(body, [], loc);\n  }\n}\n\nfunction buildBlockParams(params: ReadonlyArray<ASTv1.VarHead | string>): ASTv1.VarHead[] {\n  return params.map((p) =>\n    typeof p === 'string' ? b.var({ name: p, loc: SourceSpan.synthetic(p) }) : p\n  );\n}\n\nfunction buildBlockItself(\n  body: ASTv1.Statement[] = [],\n  params: Array<ASTv1.VarHead | string> = [],\n  chained = false,\n  loc?: SourceLocation\n): ASTv1.Block {\n  return b.blockItself({\n    body,\n    params: buildBlockParams(params),\n    chained,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildTemplate(\n  body: ASTv1.Statement[] = [],\n  blockParams: string[] = [],\n  loc?: SourceLocation\n): ASTv1.Template {\n  return b.template({\n    body,\n    blockParams,\n    loc: buildLoc(loc || null),\n  });\n}\n\nfunction buildPosition(line: number, column: number): SourcePosition {\n  return b.pos({\n    line,\n    column,\n  });\n}\n\nfunction buildLoc(loc: Nullable<SourceLocation>): SourceSpan;\nfunction buildLoc(\n  startLine: number,\n  startColumn: number,\n  endLine?: number,\n  endColumn?: number,\n  source?: string\n): SourceSpan;\nfunction buildLoc(\n  ...args:\n    | [Nullable<SourceLocation>]\n    | [\n        startLine: number,\n        startColumn: number,\n        endLine?: number | undefined,\n        endColumn?: number | undefined,\n        source?: string | undefined,\n      ]\n): SourceSpan {\n  if (args.length === 1) {\n    let loc = args[0];\n\n    if (loc && typeof loc === 'object') {\n      return SourceSpan.forHbsLoc(SOURCE(), loc);\n    } else {\n      return SourceSpan.forHbsLoc(SOURCE(), SYNTHETIC_LOCATION);\n    }\n  } else {\n    let [startLine, startColumn, endLine, endColumn, _source] = args;\n    let source = _source ? new Source('', _source) : SOURCE();\n\n    return SourceSpan.forHbsLoc(source, {\n      start: {\n        line: startLine,\n        column: startColumn,\n      },\n      end: {\n        line: endLine || startLine,\n        column: endColumn || startColumn,\n      },\n    });\n  }\n}\n\nexport default {\n  mustache: buildMustache,\n  block: buildBlock,\n  comment: buildComment,\n  mustacheComment: buildMustacheComment,\n  element: buildElement,\n  elementModifier: buildElementModifier,\n  attr: buildAttr,\n  text: buildText,\n  sexpr: buildSexpr,\n\n  concat: buildConcat,\n  hash: buildHash,\n  pair: buildPair,\n  literal: buildLiteral,\n  program: buildProgram,\n  blockItself: buildBlockItself,\n  template: buildTemplate,\n  loc: buildLoc,\n  pos: buildPosition,\n\n  path: buildPath,\n\n  fullPath: buildCleanPath,\n  head: buildHeadFromString,\n  at: buildAtName,\n  var: buildVar,\n  this: buildThis,\n\n  string: literal('StringLiteral') as (value: string) => ASTv1.StringLiteral,\n  boolean: literal('BooleanLiteral') as (value: boolean) => ASTv1.BooleanLiteral,\n  number: literal('NumberLiteral') as (value: number) => ASTv1.NumberLiteral,\n  undefined(): ASTv1.UndefinedLiteral {\n    return buildLiteral('UndefinedLiteral', undefined);\n  },\n  null(): ASTv1.NullLiteral {\n    return buildLiteral('NullLiteral', null);\n  },\n};\n\ntype BuildLiteral<T extends ASTv1.Literal> = (value: T['value']) => T;\n\nfunction literal<T extends ASTv1.Literal>(type: T['type']): BuildLiteral<T> {\n  return function (value: T['value'], loc?: SourceLocation): T {\n    return buildLiteral(type, value, loc);\n  };\n}\n","import type { Nullable, Optional, PresentArray } from '@glimmer/interfaces';\nimport { localAssert } from '@glimmer/debug-util';\n\nimport type * as ASTv1 from './api';\n\nimport { SourceSpan } from '../source/span';\nimport { buildLegacyLiteral, buildLegacyMustache, buildLegacyPath } from './legacy-interop';\n\nconst DEFAULT_STRIP = {\n  close: false,\n  open: false,\n};\n\n/**\n * The Parser Builder differentiates from the public builder API by:\n *\n * 1. Offering fewer different ways to instantiate nodes\n * 2. Mandating source locations\n */\nclass Builders {\n  pos({ line, column }: { line: number; column: number }) {\n    return {\n      line,\n      column,\n    };\n  }\n\n  blockItself({\n    body,\n    params,\n    chained = false,\n    loc,\n  }: {\n    body: ASTv1.Statement[];\n    params: ASTv1.VarHead[];\n    chained?: Optional<boolean>;\n    loc: SourceSpan;\n  }): ASTv1.Block {\n    return {\n      type: 'Block',\n      body,\n      params,\n      get blockParams() {\n        return this.params.map((p) => p.name);\n      },\n      set blockParams(params: string[]) {\n        this.params = params.map((name) => {\n          return b.var({ name, loc: SourceSpan.synthetic(name) });\n        });\n      },\n      chained,\n      loc,\n    };\n  }\n\n  template({\n    body,\n    blockParams,\n    loc,\n  }: {\n    body: ASTv1.Statement[];\n    blockParams: string[];\n    loc: SourceSpan;\n  }): ASTv1.Template {\n    return {\n      type: 'Template',\n      body,\n      blockParams,\n      loc,\n    };\n  }\n\n  mustache({\n    path,\n    params,\n    hash,\n    trusting,\n    loc,\n    strip = DEFAULT_STRIP,\n  }: {\n    path: ASTv1.Expression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    trusting: boolean;\n    loc: SourceSpan;\n    strip?: Optional<ASTv1.StripFlags>;\n  }): ASTv1.MustacheStatement {\n    return buildLegacyMustache({\n      path,\n      params,\n      hash,\n      trusting,\n      strip,\n      loc,\n    });\n  }\n\n  block({\n    path,\n    params,\n    hash,\n    defaultBlock,\n    elseBlock = null,\n    loc,\n    openStrip = DEFAULT_STRIP,\n    inverseStrip = DEFAULT_STRIP,\n    closeStrip = DEFAULT_STRIP,\n  }: {\n    path: ASTv1.PathExpression | ASTv1.SubExpression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    defaultBlock: ASTv1.Block;\n    elseBlock: Nullable<ASTv1.Block>;\n    loc: SourceSpan;\n    openStrip?: Optional<ASTv1.StripFlags>;\n    inverseStrip?: Optional<ASTv1.StripFlags>;\n    closeStrip?: Optional<ASTv1.StripFlags>;\n  }): ASTv1.BlockStatement {\n    return {\n      type: 'BlockStatement',\n      path: path,\n      params,\n      hash,\n      program: defaultBlock,\n      inverse: elseBlock,\n      loc,\n      openStrip,\n      inverseStrip,\n      closeStrip,\n    };\n  }\n\n  comment({ value, loc }: { value: string; loc: SourceSpan }): ASTv1.CommentStatement {\n    return {\n      type: 'CommentStatement',\n      value,\n      loc,\n    };\n  }\n\n  mustacheComment({\n    value,\n    loc,\n  }: {\n    value: string;\n    loc: SourceSpan;\n  }): ASTv1.MustacheCommentStatement {\n    return {\n      type: 'MustacheCommentStatement',\n      value,\n      loc,\n    };\n  }\n\n  concat({\n    parts,\n    loc,\n  }: {\n    parts: PresentArray<ASTv1.TextNode | ASTv1.MustacheStatement>;\n    loc: SourceSpan;\n  }): ASTv1.ConcatStatement {\n    return {\n      type: 'ConcatStatement',\n      parts,\n      loc,\n    };\n  }\n\n  element({\n    path,\n    selfClosing,\n    attributes,\n    modifiers,\n    params,\n    comments,\n    children,\n    openTag,\n    closeTag,\n    loc,\n  }: {\n    path: ASTv1.PathExpression;\n    selfClosing: boolean;\n    attributes: ASTv1.AttrNode[];\n    modifiers: ASTv1.ElementModifierStatement[];\n    params: ASTv1.VarHead[];\n    children: ASTv1.Statement[];\n    comments: ASTv1.MustacheCommentStatement[];\n    openTag: SourceSpan;\n    closeTag: Nullable<SourceSpan>;\n    loc: SourceSpan;\n  }): ASTv1.ElementNode {\n    let _selfClosing = selfClosing;\n\n    return {\n      type: 'ElementNode',\n      path,\n      attributes,\n      modifiers,\n      params,\n      comments,\n      children,\n      openTag,\n      closeTag,\n      loc,\n      get tag() {\n        return this.path.original;\n      },\n      set tag(name: string) {\n        this.path.original = name;\n      },\n      get blockParams() {\n        return this.params.map((p) => p.name);\n      },\n      set blockParams(params: string[]) {\n        this.params = params.map((name) => {\n          return b.var({ name, loc: SourceSpan.synthetic(name) });\n        });\n      },\n      get selfClosing() {\n        return _selfClosing;\n      },\n      set selfClosing(selfClosing: boolean) {\n        _selfClosing = selfClosing;\n\n        if (selfClosing) {\n          this.closeTag = null;\n        } else {\n          this.closeTag = SourceSpan.synthetic(`</${this.tag}>`);\n        }\n      },\n    };\n  }\n\n  elementModifier({\n    path,\n    params,\n    hash,\n    loc,\n  }: {\n    path: ASTv1.PathExpression | ASTv1.SubExpression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    loc: SourceSpan;\n  }): ASTv1.ElementModifierStatement {\n    return {\n      type: 'ElementModifierStatement',\n      path,\n      params,\n      hash,\n      loc,\n    };\n  }\n\n  attr({\n    name,\n    value,\n    loc,\n  }: {\n    name: string;\n    value: ASTv1.AttrNode['value'];\n    loc: SourceSpan;\n  }): ASTv1.AttrNode {\n    return {\n      type: 'AttrNode',\n      name: name,\n      value: value,\n      loc,\n    };\n  }\n\n  text({ chars, loc }: { chars: string; loc: SourceSpan }): ASTv1.TextNode {\n    return {\n      type: 'TextNode',\n      chars,\n      loc,\n    };\n  }\n\n  sexpr({\n    path,\n    params,\n    hash,\n    loc,\n  }: {\n    path: ASTv1.PathExpression | ASTv1.SubExpression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    loc: SourceSpan;\n  }): ASTv1.SubExpression {\n    return {\n      type: 'SubExpression',\n      path,\n      params,\n      hash,\n      loc,\n    };\n  }\n\n  path({\n    head,\n    tail,\n    loc,\n  }: {\n    head: ASTv1.PathHead;\n    tail: string[];\n    loc: SourceSpan;\n  }): ASTv1.PathExpression {\n    return buildLegacyPath({ head, tail, loc });\n  }\n\n  head({ original, loc }: { original: string; loc: SourceSpan }): ASTv1.PathHead {\n    if (original === 'this') {\n      return this.this({ loc });\n    }\n    if (original[0] === '@') {\n      return this.atName({ name: original, loc });\n    } else {\n      return this.var({ name: original, loc });\n    }\n  }\n\n  this({ loc }: { loc: SourceSpan }): ASTv1.ThisHead {\n    return {\n      type: 'ThisHead',\n      get original() {\n        return 'this' as const;\n      },\n      loc,\n    };\n  }\n\n  atName({ name, loc }: { name: string; loc: SourceSpan }): ASTv1.AtHead {\n    let _name = '';\n\n    const node = {\n      type: 'AtHead' as const,\n      get name() {\n        return _name;\n      },\n      set name(value) {\n        localAssert(value[0] === '@', `call builders.at() with a string that starts with '@'`);\n        localAssert(\n          value.indexOf('.') === -1,\n          `builder.at() should not be called with a name with dots in it`\n        );\n        _name = value;\n      },\n      get original() {\n        return this.name;\n      },\n      set original(value) {\n        this.name = value;\n      },\n      loc,\n    };\n\n    // trigger the assertions\n    node.name = name;\n\n    return node;\n  }\n\n  var({ name, loc }: { name: string; loc: SourceSpan }): ASTv1.VarHead {\n    let _name = '';\n\n    const node = {\n      type: 'VarHead' as const,\n      get name() {\n        return _name;\n      },\n      set name(value) {\n        localAssert(\n          value !== 'this',\n          `You called builders.var() with 'this'. Call builders.this instead`\n        );\n        localAssert(\n          value[0] !== '@',\n          `You called builders.var() with '${name}'. Call builders.at('${name}') instead`\n        );\n        localAssert(\n          value.indexOf('.') === -1,\n          `builder.var() should not be called with a name with dots in it`\n        );\n        _name = value;\n      },\n      get original() {\n        return this.name;\n      },\n      set original(value) {\n        this.name = value;\n      },\n      loc,\n    };\n\n    // trigger the assertions\n    node.name = name;\n\n    return node;\n  }\n\n  hash({ pairs, loc }: { pairs: ASTv1.HashPair[]; loc: SourceSpan }): ASTv1.Hash {\n    return {\n      type: 'Hash',\n      pairs,\n      loc,\n    };\n  }\n\n  pair({\n    key,\n    value,\n    loc,\n  }: {\n    key: string;\n    value: ASTv1.Expression;\n    loc: SourceSpan;\n  }): ASTv1.HashPair {\n    return {\n      type: 'HashPair',\n      key,\n      value,\n      loc,\n    };\n  }\n\n  literal<T extends ASTv1.Literal>({\n    type,\n    value,\n    loc,\n  }: {\n    type: T['type'];\n    value: T['value'];\n    loc: SourceSpan;\n  }): T {\n    return buildLegacyLiteral({ type, value, loc });\n  }\n}\n\nconst b = new Builders();\n\nexport default b;\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { asPresentArray, deprecate } from '@glimmer/debug-util';\n\nimport type * as ASTv1 from './nodes-v1';\n\nimport b from './public-builders';\n\nexport type MustacheStatementParams = Omit<ASTv1.MustacheStatement, 'type' | 'escaped'>;\n\nexport function buildLegacyMustache({\n  path,\n  params,\n  hash,\n  trusting,\n  strip,\n  loc,\n}: MustacheStatementParams): ASTv1.MustacheStatement {\n  const node = {\n    type: 'MustacheStatement',\n    path,\n    params,\n    hash,\n    trusting,\n    strip,\n    loc,\n  };\n\n  Object.defineProperty(node, 'escaped', {\n    enumerable: false,\n    get(this: typeof node): boolean {\n      deprecate(`The escaped property on mustache nodes is deprecated, use trusting instead`);\n      return !this.trusting;\n    },\n    set(this: typeof node, value: boolean) {\n      deprecate(`The escaped property on mustache nodes is deprecated, use trusting instead`);\n      this.trusting = !value;\n    },\n  });\n\n  return node as ASTv1.MustacheStatement;\n}\n\nexport type PathExpressionParams = Omit<ASTv1.MinimalPathExpression, 'type'>;\n\nexport function buildLegacyPath({ head, tail, loc }: PathExpressionParams): ASTv1.PathExpression {\n  const node = {\n    type: 'PathExpression',\n    head,\n    tail,\n    get original() {\n      return [this.head.original, ...this.tail].join('.');\n    },\n    set original(value: string) {\n      let [head, ...tail] = asPresentArray(value.split('.'));\n      this.head = b.head(head, this.head.loc);\n      this.tail = tail;\n    },\n    loc,\n  };\n\n  Object.defineProperty(node, 'parts', {\n    enumerable: false,\n    get(this: { original: string }): readonly string[] {\n      deprecate(`The parts property on path nodes is deprecated, use head and tail instead`);\n      let parts = asPresentArray(this.original.split('.'));\n\n      if (parts[0] === 'this') {\n        // parts does not include `this`\n        parts.shift();\n      } else if (parts[0].startsWith('@')) {\n        // parts does not include leading `@`\n        parts[0] = parts[0].slice(1);\n      }\n\n      return Object.freeze(parts);\n    },\n    set(this: { head: ASTv1.PathHead; original: string }, values: PresentArray<string>) {\n      deprecate(`The parts property on mustache nodes is deprecated, use head and tail instead`);\n\n      let parts = [...values];\n\n      // you are not supposed to already have `this` or `@` in the parts, but since this is\n      // deprecated anyway, we will infer what you meant and allow it\n      if (parts[0] !== 'this' && !parts[0]?.startsWith('@')) {\n        if (this.head.type === 'ThisHead') {\n          parts.unshift('this');\n        } else if (this.head.type === 'AtHead') {\n          parts[0] = `@${parts[0]}`;\n        }\n      }\n\n      this.original = parts.join('.');\n    },\n  });\n\n  Object.defineProperty(node, 'this', {\n    enumerable: false,\n    get(this: typeof node): boolean {\n      deprecate(`The this property on path nodes is deprecated, use head.type instead`);\n      return this.head.type === 'ThisHead';\n    },\n  });\n\n  Object.defineProperty(node, 'data', {\n    enumerable: false,\n    get(this: typeof node): boolean {\n      deprecate(`The data property on path nodes is deprecated, use head.type instead`);\n      return this.head.type === 'AtHead';\n    },\n  });\n\n  return node as ASTv1.PathExpression;\n}\n\nexport function buildLegacyLiteral<T extends ASTv1.Literal>({\n  type,\n  value,\n  loc,\n}: {\n  type: T['type'];\n  value: T['value'];\n  loc: T['loc'];\n}): T {\n  const node = {\n    type,\n    value,\n    loc,\n  };\n\n  Object.defineProperty(node, 'original', {\n    enumerable: false,\n    get(this: typeof node): T['original'] {\n      deprecate(`The original property on literal nodes is deprecated, use value instead`);\n      return this.value;\n    },\n    set(this: typeof node, value: T['original']) {\n      deprecate(`The original property on literal nodes is deprecated, use value instead`);\n      this.value = value;\n    },\n  });\n\n  return node as T;\n}\n","import type { Nullable } from '@glimmer/interfaces';\nimport { asPresentArray, expect, getLast, localAssert, unwrap } from '@glimmer/debug-util';\nimport { assign } from '@glimmer/util';\nimport {\n  EntityParser,\n  EventedTokenizer,\n  HTML5NamedCharRefs as namedCharRefs,\n} from 'simple-html-tokenizer';\n\nimport type * as src from './source/api';\nimport type * as ASTv1 from './v1/api';\nimport type * as HBS from './v1/handlebars-ast';\n\nexport type ParserNodeBuilder<N extends { loc: src.SourceSpan }> = Omit<N, 'loc'> & {\n  start: src.SourceOffset;\n};\n\nexport interface StartTag {\n  readonly type: 'StartTag';\n  name: string;\n  nameStart: Nullable<src.SourceOffset>;\n  nameEnd: Nullable<src.SourceOffset>;\n  readonly attributes: ASTv1.AttrNode[];\n  readonly modifiers: ASTv1.ElementModifierStatement[];\n  readonly comments: ASTv1.MustacheCommentStatement[];\n  readonly params: ASTv1.VarHead[];\n  selfClosing: boolean;\n  readonly loc: src.SourceSpan;\n}\n\nexport interface EndTag {\n  readonly type: 'EndTag';\n  name: string;\n  readonly loc: src.SourceSpan;\n}\n\nexport interface Attribute {\n  name: string;\n  currentPart: ASTv1.TextNode | null;\n  parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[];\n  isQuoted: boolean;\n  isDynamic: boolean;\n  start: src.SourceOffset;\n  valueSpan: src.SourceSpan;\n}\n\nexport abstract class Parser {\n  protected elementStack: ASTv1.ParentNode[] = [];\n  private lines: string[];\n  readonly source: src.Source;\n  public currentAttribute: Nullable<Attribute> = null;\n  public currentNode: Nullable<\n    Readonly<\n      | ParserNodeBuilder<ASTv1.CommentStatement>\n      | ParserNodeBuilder<ASTv1.TextNode>\n      | ParserNodeBuilder<StartTag>\n      | ParserNodeBuilder<EndTag>\n    >\n  > = null;\n  public tokenizer: EventedTokenizer;\n\n  constructor(\n    source: src.Source,\n    entityParser = new EntityParser(namedCharRefs),\n    mode: 'precompile' | 'codemod' = 'precompile'\n  ) {\n    this.source = source;\n    this.lines = source.source.split(/\\r\\n?|\\n/u);\n    this.tokenizer = new EventedTokenizer(this, entityParser, mode);\n  }\n\n  offset(): src.SourceOffset {\n    let { line, column } = this.tokenizer;\n    return this.source.offsetFor(line, column);\n  }\n\n  pos({ line, column }: src.SourcePosition): src.SourceOffset {\n    return this.source.offsetFor(line, column);\n  }\n\n  finish<T extends { loc: src.SourceSpan }>(node: ParserNodeBuilder<T>): T {\n    return assign({}, node, {\n      loc: node.start.until(this.offset()),\n    } as const) as unknown as T;\n\n    // node.loc = node.loc.withEnd(end);\n  }\n\n  abstract parse(node: HBS.Program, locals: string[]): ASTv1.Template;\n\n  abstract Program(node: HBS.Program): HBS.Output<'Program'>;\n  abstract MustacheStatement(node: HBS.MustacheStatement): HBS.Output<'MustacheStatement'>;\n  abstract Decorator(node: HBS.Decorator): HBS.Output<'Decorator'>;\n  abstract BlockStatement(node: HBS.BlockStatement): HBS.Output<'BlockStatement'>;\n  abstract DecoratorBlock(node: HBS.DecoratorBlock): HBS.Output<'DecoratorBlock'>;\n  abstract PartialStatement(node: HBS.PartialStatement): HBS.Output<'PartialStatement'>;\n  abstract PartialBlockStatement(\n    node: HBS.PartialBlockStatement\n  ): HBS.Output<'PartialBlockStatement'>;\n  abstract ContentStatement(node: HBS.ContentStatement): HBS.Output<'ContentStatement'>;\n  abstract CommentStatement(node: HBS.CommentStatement): HBS.Output<'CommentStatement'>;\n  abstract SubExpression(node: HBS.SubExpression): HBS.Output<'SubExpression'>;\n  abstract PathExpression(node: HBS.PathExpression): HBS.Output<'PathExpression'>;\n  abstract StringLiteral(node: HBS.StringLiteral): HBS.Output<'StringLiteral'>;\n  abstract BooleanLiteral(node: HBS.BooleanLiteral): HBS.Output<'BooleanLiteral'>;\n  abstract NumberLiteral(node: HBS.NumberLiteral): HBS.Output<'NumberLiteral'>;\n  abstract UndefinedLiteral(node: HBS.UndefinedLiteral): HBS.Output<'UndefinedLiteral'>;\n  abstract NullLiteral(node: HBS.NullLiteral): HBS.Output<'NullLiteral'>;\n\n  abstract reset(): void;\n  abstract finishData(): void;\n  abstract tagOpen(): void;\n  abstract beginData(): void;\n  abstract appendToData(char: string): void;\n  abstract beginStartTag(): void;\n  abstract appendToTagName(char: string): void;\n  abstract beginAttribute(): void;\n  abstract appendToAttributeName(char: string): void;\n  abstract beginAttributeValue(quoted: boolean): void;\n  abstract appendToAttributeValue(char: string): void;\n  abstract finishAttributeValue(): void;\n  abstract markTagAsSelfClosing(): void;\n  abstract beginEndTag(): void;\n  abstract finishTag(): void;\n  abstract beginComment(): void;\n  abstract appendToCommentData(char: string): void;\n  abstract finishComment(): void;\n  abstract reportSyntaxError(error: string): void;\n\n  get currentAttr(): Attribute {\n    return expect(this.currentAttribute, 'expected attribute');\n  }\n\n  get currentTag(): ParserNodeBuilder<StartTag> | ParserNodeBuilder<EndTag> {\n    let node = this.currentNode;\n    localAssert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');\n    return node;\n  }\n\n  get currentStartTag(): ParserNodeBuilder<StartTag> {\n    let node = this.currentNode;\n    localAssert(node && node.type === 'StartTag', 'expected start tag');\n    return node;\n  }\n\n  get currentEndTag(): ParserNodeBuilder<EndTag> {\n    let node = this.currentNode;\n    localAssert(node && node.type === 'EndTag', 'expected end tag');\n    return node;\n  }\n\n  get currentComment(): ParserNodeBuilder<ASTv1.CommentStatement> {\n    let node = this.currentNode;\n    localAssert(node && node.type === 'CommentStatement', 'expected a comment');\n    return node;\n  }\n\n  get currentData(): ParserNodeBuilder<ASTv1.TextNode> {\n    let node = this.currentNode;\n    localAssert(node && node.type === 'TextNode', 'expected a text node');\n    return node;\n  }\n\n  acceptNode<T extends HBS.NodeType>(node: HBS.Node<T>): HBS.Output<T> {\n    return (this[node.type as T] as (node: HBS.Node<T>) => HBS.Output<T>)(node);\n  }\n\n  currentElement(): ASTv1.ParentNode {\n    return getLast(asPresentArray(this.elementStack));\n  }\n\n  sourceForNode(node: HBS.Node, endNode?: { loc: HBS.SourceLocation }): string {\n    let firstLine = node.loc.start.line - 1;\n    let currentLine = firstLine - 1;\n    let firstColumn = node.loc.start.column;\n    let string = [];\n    let line: string;\n\n    let lastLine: number;\n    let lastColumn: number;\n\n    if (endNode) {\n      lastLine = endNode.loc.end.line - 1;\n      lastColumn = endNode.loc.end.column;\n    } else {\n      lastLine = node.loc.end.line - 1;\n      lastColumn = node.loc.end.column;\n    }\n\n    while (currentLine < lastLine) {\n      currentLine++;\n      line = unwrap(this.lines[currentLine]);\n\n      if (currentLine === firstLine) {\n        if (firstLine === lastLine) {\n          string.push(line.slice(firstColumn, lastColumn));\n        } else {\n          string.push(line.slice(firstColumn));\n        }\n      } else if (currentLine === lastLine) {\n        string.push(line.slice(0, lastColumn));\n      } else {\n        string.push(line);\n      }\n    }\n\n    return string.join('\\n');\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\nimport type { Nullable, Recast } from '@glimmer/interfaces';\nimport type { TokenizerState } from 'simple-html-tokenizer';\nimport { getLast, isPresentArray, localAssert, unwrap } from '@glimmer/debug-util';\n\nimport type { ParserNodeBuilder, StartTag } from '../parser';\nimport type * as src from '../source/api';\nimport type { SourceOffset, SourceSpan } from '../source/span';\nimport type * as ASTv1 from '../v1/api';\nimport type * as HBS from '../v1/handlebars-ast';\n\nimport { Parser } from '../parser';\nimport { NON_EXISTENT_LOCATION } from '../source/location';\nimport { generateSyntaxError } from '../syntax-error';\nimport { appendChild, isHBSLiteral, printLiteral } from '../utils';\nimport b from '../v1/parser-builders';\n\nconst BEFORE_ATTRIBUTE_NAME = 'beforeAttributeName' as TokenizerState.beforeAttributeName;\nconst ATTRIBUTE_VALUE_UNQUOTED = 'attributeValueUnquoted' as TokenizerState.attributeValueUnquoted;\n\nexport interface PendingError {\n  mustache(span: SourceSpan): never;\n  eof(offset: SourceOffset): never;\n}\n\nexport abstract class HandlebarsNodeVisitors extends Parser {\n  // Because we interleave the HTML and HBS parsing, sometimes the HTML\n  // tokenizer can run out of tokens when we switch into {{...}} or reached\n  // EOF. There are positions where neither of these are expected, and it would\n  // like to generate an error, but there is no span to attach the error to.\n  // This allows the HTML tokenization to stash an error message and the next\n  // mustache visitor will attach the message to the appropriate span and throw\n  // the error.\n  protected pendingError: Nullable<PendingError> = null;\n\n  abstract override appendToCommentData(s: string): void;\n  abstract override beginAttributeValue(quoted: boolean): void;\n  abstract override finishAttributeValue(): void;\n\n  parse(program: HBS.UpstreamProgram, blockParams: string[]): ASTv1.Template {\n    localAssert(program.loc, '[BUG] Program in parser unexpectedly did not have loc');\n\n    let node = b.template({\n      body: [],\n      blockParams,\n      loc: this.source.spanFor(program.loc),\n    });\n\n    let template = this.parseProgram(node, program);\n\n    // TODO: we really need to verify that the tokenizer is in an acceptable\n    // state when we are \"done\" parsing. For example, right now, `<foo` parses\n    // into `Template { body: [] }` which is obviously incorrect\n\n    this.pendingError?.eof(template.loc.getEnd());\n\n    return template;\n  }\n\n  Program(program: HBS.Program, blockParams?: ASTv1.VarHead[]): ASTv1.Block {\n    // The abstract signature doesn't have the blockParams argument, but in\n    // practice we can only come from this.BlockStatement() which adds the\n    // extra argument for us\n    localAssert(\n      Array.isArray(blockParams),\n      '[BUG] Program in parser unexpectedly called without block params'\n    );\n\n    localAssert(\n      program.loc,\n      '[BUG] Program in parser unexpectedly did not have loc. This should have been fixed in BlockStatement'\n    );\n\n    let node = b.blockItself({\n      body: [],\n      params: blockParams,\n      chained: program.chained,\n      loc: this.source.spanFor(program.loc),\n    });\n\n    return this.parseProgram(node, program);\n  }\n\n  private parseProgram<T extends ASTv1.ParentNode>(node: T, program: HBS.UpstreamProgram): T {\n    if (program.body.length === 0) {\n      return node;\n    }\n\n    let poppedNode;\n\n    try {\n      this.elementStack.push(node);\n\n      for (let child of program.body) {\n        this.acceptNode(child);\n      }\n    } finally {\n      poppedNode = this.elementStack.pop();\n    }\n\n    // Ensure that that the element stack is balanced properly.\n    if (node !== poppedNode) {\n      if (poppedNode?.type === 'ElementNode') {\n        throw generateSyntaxError(`Unclosed element \\`${poppedNode.tag}\\``, poppedNode.loc);\n      } else {\n        // If the stack is not balanced, then it is likely our own bug, because\n        // any unclosed Handlebars blocks should already been caught by now\n        localAssert(poppedNode !== undefined, '[BUG] empty parser elementStack');\n        localAssert(false, `[BUG] mismatched parser elementStack node: ${node.type}`);\n      }\n    }\n\n    return node;\n  }\n\n  BlockStatement(block: HBS.UpstreamBlockStatement): ASTv1.BlockStatement | void {\n    if (this.tokenizer.state === 'comment') {\n      localAssert(block.loc, '[BUG] BlockStatement in parser unexpectedly did not have loc');\n      this.appendToCommentData(this.sourceForNode(block as HBS.Node));\n      return;\n    }\n\n    if (this.tokenizer.state !== 'data' && this.tokenizer.state !== 'beforeData') {\n      throw generateSyntaxError(\n        'A block may only be used inside an HTML element or another block.',\n        this.source.spanFor(block.loc)\n      );\n    }\n\n    const { path, params, hash } = acceptCallNodes(this, block);\n    const loc = this.source.spanFor(block.loc);\n\n    // Backfill block params loc for the default block\n    let blockParams: ASTv1.VarHead[] = [];\n    let repairedBlock: HBS.BlockStatement;\n\n    if (block.program.blockParams?.length) {\n      // Start from right after the hash\n      let span = hash.loc.collapse('end');\n\n      // Extend till the beginning of the block\n      if (block.program.loc) {\n        span = span.withEnd(this.source.spanFor(block.program.loc).getStart());\n      } else if (block.program.body[0]) {\n        span = span.withEnd(this.source.spanFor(block.program.body[0].loc).getStart());\n      } else {\n        // ...or if all else fail, use the end of the block statement\n        // this can only happen if the block statement is empty anyway\n        span = span.withEnd(loc.getEnd());\n      }\n\n      repairedBlock = repairBlock(this.source, block, span);\n\n      // Now we have a span for something like this:\n      //\n      //   {{#foo bar baz=bat as |wow wat|}}\n      //                     ~~~~~~~~~~~~~~~\n      //\n      // Or, if we are unlucky:\n      //\n      // {{#foo bar baz=bat as |wow wat|}}{{/foo}}\n      //                   ~~~~~~~~~~~~~~~~~~~~~~~\n      //\n      // Either way, within this span, there should be exactly two pipes\n      // fencing our block params, neatly whitespace separated and with\n      // legal identifiers only\n      const content = span.asString();\n      let skipStart = content.indexOf('|') + 1;\n      const limit = content.indexOf('|', skipStart);\n\n      for (const name of block.program.blockParams) {\n        let nameStart: number;\n        let loc: SourceSpan;\n\n        if (skipStart >= limit) {\n          nameStart = -1;\n        } else {\n          nameStart = content.indexOf(name, skipStart);\n        }\n\n        if (nameStart === -1 || nameStart + name.length > limit) {\n          skipStart = limit;\n          loc = this.source.spanFor(NON_EXISTENT_LOCATION);\n        } else {\n          skipStart = nameStart;\n          loc = span.sliceStartChars({ skipStart, chars: name.length });\n          skipStart += name.length;\n        }\n\n        blockParams.push(b.var({ name, loc }));\n      }\n    } else {\n      repairedBlock = repairBlock(this.source, block, loc);\n    }\n\n    const program = this.Program(repairedBlock.program, blockParams);\n    const inverse = repairedBlock.inverse ? this.Program(repairedBlock.inverse, []) : null;\n\n    const node = b.block({\n      path,\n      params,\n      hash,\n      defaultBlock: program,\n      elseBlock: inverse,\n      loc: this.source.spanFor(block.loc),\n      openStrip: block.openStrip,\n      inverseStrip: block.inverseStrip,\n      closeStrip: block.closeStrip,\n    });\n\n    const parentProgram = this.currentElement();\n\n    appendChild(parentProgram, node);\n  }\n\n  MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void {\n    this.pendingError?.mustache(this.source.spanFor(rawMustache.loc));\n\n    const { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawMustache));\n      return;\n    }\n\n    let mustache: ASTv1.MustacheStatement;\n    const { escaped, loc, strip } = rawMustache;\n\n    if ('original' in rawMustache.path && rawMustache.path.original === '...attributes') {\n      throw generateSyntaxError(\n        'Illegal use of ...attributes',\n        this.source.spanFor(rawMustache.loc)\n      );\n    }\n\n    if (isHBSLiteral(rawMustache.path)) {\n      mustache = b.mustache({\n        path: this.acceptNode<(typeof rawMustache.path)['type']>(rawMustache.path),\n        params: [],\n        hash: b.hash({ pairs: [], loc: this.source.spanFor(rawMustache.path.loc).collapse('end') }),\n        trusting: !escaped,\n        loc: this.source.spanFor(loc),\n        strip,\n      });\n    } else {\n      const { path, params, hash } = acceptCallNodes(\n        this,\n        rawMustache as HBS.MustacheStatement & {\n          path: HBS.PathExpression | HBS.SubExpression;\n        }\n      );\n      mustache = b.mustache({\n        path,\n        params,\n        hash,\n        trusting: !escaped,\n        loc: this.source.spanFor(loc),\n        strip,\n      });\n    }\n\n    switch (tokenizer.state) {\n      // Tag helpers\n      case 'tagOpen':\n      case 'tagName':\n        throw generateSyntaxError(`Cannot use mustaches in an elements tagname`, mustache.loc);\n\n      case 'beforeAttributeName':\n        addElementModifier(this.currentStartTag, mustache);\n        break;\n      case 'attributeName':\n      case 'afterAttributeName':\n        this.beginAttributeValue(false);\n        this.finishAttributeValue();\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n        break;\n      case 'afterAttributeValueQuoted':\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n        break;\n\n      // Attribute values\n      case 'beforeAttributeValue':\n        this.beginAttributeValue(false);\n        this.appendDynamicAttributeValuePart(mustache);\n        tokenizer.transitionTo(ATTRIBUTE_VALUE_UNQUOTED);\n        break;\n      case 'attributeValueDoubleQuoted':\n      case 'attributeValueSingleQuoted':\n      case 'attributeValueUnquoted':\n        this.appendDynamicAttributeValuePart(mustache);\n        break;\n\n      // TODO: Only append child when the tokenizer state makes\n      // sense to do so, otherwise throw an error.\n      default:\n        appendChild(this.currentElement(), mustache);\n    }\n\n    return mustache;\n  }\n\n  appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void {\n    this.finalizeTextPart();\n    const attr = this.currentAttr;\n    attr.isDynamic = true;\n    attr.parts.push(part);\n  }\n\n  finalizeTextPart(): void {\n    const attr = this.currentAttr;\n    const text = attr.currentPart;\n    if (text !== null) {\n      this.currentAttr.parts.push(text);\n      this.startTextPart();\n    }\n  }\n\n  startTextPart(): void {\n    this.currentAttr.currentPart = null;\n  }\n\n  ContentStatement(content: HBS.ContentStatement): void {\n    updateTokenizerLocation(this.tokenizer, content);\n\n    this.tokenizer.tokenizePart(content.value);\n    this.tokenizer.flushData();\n  }\n\n  CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement> {\n    const { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawComment));\n      return null;\n    }\n\n    const { value, loc } = rawComment;\n    const comment = b.mustacheComment({ value, loc: this.source.spanFor(loc) });\n\n    switch (tokenizer.state) {\n      case 'beforeAttributeName':\n      case 'afterAttributeName':\n        this.currentStartTag.comments.push(comment);\n        break;\n\n      case 'beforeData':\n      case 'data':\n        appendChild(this.currentElement(), comment);\n        break;\n\n      default:\n        throw generateSyntaxError(\n          `Using a Handlebars comment when in the \\`${tokenizer['state']}\\` state is not supported`,\n          this.source.spanFor(rawComment.loc)\n        );\n    }\n\n    return comment;\n  }\n\n  PartialStatement(partial: HBS.PartialStatement): never {\n    throw generateSyntaxError(\n      `Handlebars partials are not supported`,\n      this.source.spanFor(partial.loc)\n    );\n  }\n\n  PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never {\n    throw generateSyntaxError(\n      `Handlebars partial blocks are not supported`,\n      this.source.spanFor(partialBlock.loc)\n    );\n  }\n\n  Decorator(decorator: HBS.Decorator): never {\n    throw generateSyntaxError(\n      `Handlebars decorators are not supported`,\n      this.source.spanFor(decorator.loc)\n    );\n  }\n\n  DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never {\n    throw generateSyntaxError(\n      `Handlebars decorator blocks are not supported`,\n      this.source.spanFor(decoratorBlock.loc)\n    );\n  }\n\n  SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression {\n    const { path, params, hash } = acceptCallNodes(this, sexpr);\n    return b.sexpr({ path, params, hash, loc: this.source.spanFor(sexpr.loc) });\n  }\n\n  PathExpression(path: HBS.PathExpression): ASTv1.PathExpression {\n    const { original } = path;\n    let parts: string[];\n\n    if (original.indexOf('/') !== -1) {\n      if (original.slice(0, 2) === './') {\n        throw generateSyntaxError(\n          `Using \"./\" is not supported in Glimmer and unnecessary`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      if (original.slice(0, 3) === '../') {\n        throw generateSyntaxError(\n          `Changing context using \"../\" is not supported in Glimmer`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      if (original.indexOf('.') !== -1) {\n        throw generateSyntaxError(\n          `Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      parts = [path.parts.join('/')];\n    } else if (original === '.') {\n      throw generateSyntaxError(\n        `'.' is not a supported path in Glimmer; check for a path with a trailing '.'`,\n        this.source.spanFor(path.loc)\n      );\n    } else {\n      parts = path.parts;\n    }\n\n    let thisHead = false;\n\n    // This is to fix a bug in the Handlebars AST where the path expressions in\n    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)\n    // are simply turned into `{{foo}}`. The fix is to push it back onto the\n    // parts array and let the runtime see the difference. However, we cannot\n    // simply use the string `this` as it means literally the property called\n    // \"this\" in the current context (it can be expressed in the syntax as\n    // `{{[this]}}`, where the square bracket are generally for this kind of\n    // escaping – such as `{{foo.[\"bar.baz\"]}}` would mean lookup a property\n    // named literally \"bar.baz\" on `this.foo`). By convention, we use `null`\n    // for this purpose.\n    if (/^this(?:\\..+)?$/u.test(original)) {\n      thisHead = true;\n    }\n\n    let pathHead: ASTv1.PathHead;\n    if (thisHead) {\n      pathHead = b.this({\n        loc: this.source.spanFor({\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + 4 },\n        }),\n      });\n    } else if (path.data) {\n      const head = parts.shift();\n\n      if (head === undefined) {\n        throw generateSyntaxError(\n          `Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.`,\n          this.source.spanFor(path.loc)\n        );\n      }\n\n      pathHead = b.atName({\n        name: `@${head}`,\n        loc: this.source.spanFor({\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + head.length + 1 },\n        }),\n      });\n    } else {\n      const head = parts.shift();\n\n      if (head === undefined) {\n        throw generateSyntaxError(\n          `Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.`,\n          this.source.spanFor(path.loc)\n        );\n      }\n\n      pathHead = b.var({\n        name: head,\n        loc: this.source.spanFor({\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + head.length },\n        }),\n      });\n    }\n\n    return b.path({\n      head: pathHead,\n      tail: parts,\n      loc: this.source.spanFor(path.loc),\n    });\n  }\n\n  Hash(hash: HBS.Hash): ASTv1.Hash {\n    const pairs = hash.pairs.map((pair) =>\n      b.pair({\n        key: pair.key,\n        value: this.acceptNode<HBS.Expression['type']>(pair.value),\n        loc: this.source.spanFor(pair.loc),\n      })\n    );\n\n    return b.hash({ pairs, loc: this.source.spanFor(hash.loc) });\n  }\n\n  StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral {\n    return b.literal({\n      type: 'StringLiteral',\n      value: string.value,\n      loc: this.source.spanFor(string.loc),\n    });\n  }\n\n  BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral {\n    return b.literal({\n      type: 'BooleanLiteral',\n      value: boolean.value,\n      loc: this.source.spanFor(boolean.loc),\n    });\n  }\n\n  NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral {\n    return b.literal({\n      type: 'NumberLiteral',\n      value: number.value,\n      loc: this.source.spanFor(number.loc),\n    });\n  }\n\n  UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral {\n    return b.literal({\n      type: 'UndefinedLiteral',\n      value: undefined,\n      loc: this.source.spanFor(undef.loc),\n    });\n  }\n\n  NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral {\n    return b.literal({\n      type: 'NullLiteral',\n      value: null,\n      loc: this.source.spanFor(nul.loc),\n    });\n  }\n}\n\nfunction calculateRightStrippedOffsets(original: string, value: string) {\n  if (value === '') {\n    // if it is empty, just return the count of newlines\n    // in original\n    return {\n      lines: original.split('\\n').length - 1,\n      columns: 0,\n    };\n  }\n\n  // otherwise, return the number of newlines prior to\n  // `value`\n  const [difference] = original.split(value) as [string];\n  const lines = difference.split(/\\n/u);\n  const lineCount = lines.length - 1;\n\n  return {\n    lines: lineCount,\n    columns: unwrap(lines[lineCount]).length,\n  };\n}\n\nfunction updateTokenizerLocation(tokenizer: Parser['tokenizer'], content: HBS.ContentStatement) {\n  let line = content.loc.start.line;\n  let column = content.loc.start.column;\n\n  const offsets = calculateRightStrippedOffsets(\n    content.original as Recast<HBS.StripFlags, string>,\n    content.value\n  );\n\n  line = line + offsets.lines;\n  if (offsets.lines) {\n    column = offsets.columns;\n  } else {\n    column = column + offsets.columns;\n  }\n\n  tokenizer.line = line;\n  tokenizer.column = column;\n}\n\nfunction acceptCallNodes(\n  compiler: HandlebarsNodeVisitors,\n  node: {\n    path:\n      | HBS.PathExpression\n      | HBS.SubExpression\n      | HBS.StringLiteral\n      | HBS.UndefinedLiteral\n      | HBS.NullLiteral\n      | HBS.NumberLiteral\n      | HBS.BooleanLiteral;\n    params: HBS.Expression[];\n    hash?: HBS.Hash;\n  }\n): {\n  path: ASTv1.PathExpression | ASTv1.SubExpression;\n  params: ASTv1.Expression[];\n  hash: ASTv1.Hash;\n} {\n  let path: ASTv1.PathExpression | ASTv1.SubExpression;\n\n  switch (node.path.type) {\n    case 'PathExpression':\n      path = compiler.PathExpression(node.path);\n      break;\n\n    case 'SubExpression':\n      path = compiler.SubExpression(node.path);\n      break;\n\n    case 'StringLiteral':\n    case 'UndefinedLiteral':\n    case 'NullLiteral':\n    case 'NumberLiteral':\n    case 'BooleanLiteral': {\n      let value: string;\n      if (node.path.type === 'BooleanLiteral') {\n        value = node.path.original.toString();\n      } else if (node.path.type === 'StringLiteral') {\n        value = `\"${node.path.original}\"`;\n      } else if (node.path.type === 'NullLiteral') {\n        value = 'null';\n      } else if (node.path.type === 'NumberLiteral') {\n        value = node.path.value.toString();\n      } else {\n        value = 'undefined';\n      }\n      throw generateSyntaxError(\n        `${node.path.type} \"${\n          node.path.type === 'StringLiteral' ? node.path.original : value\n        }\" cannot be called as a sub-expression, replace (${value}) with ${value}`,\n        compiler.source.spanFor(node.path.loc)\n      );\n    }\n  }\n\n  const params = node.params.map((e) => compiler.acceptNode<HBS.Expression['type']>(e));\n\n  // if there is no hash, position it as a collapsed node immediately after the last param (or the\n  // path, if there are also no params)\n  const end = isPresentArray(params) ? getLast(params).loc : path.loc;\n\n  const hash = node.hash\n    ? compiler.Hash(node.hash)\n    : b.hash({\n        pairs: [],\n        loc: compiler.source.spanFor(end).collapse('end'),\n      });\n\n  return { path, params, hash };\n}\n\nfunction addElementModifier(\n  element: ParserNodeBuilder<StartTag>,\n  mustache: ASTv1.MustacheStatement\n) {\n  const { path, params, hash, loc } = mustache;\n\n  if (isHBSLiteral(path)) {\n    const modifier = `{{${printLiteral(path)}}}`;\n    const tag = `<${element.name} ... ${modifier} ...`;\n\n    throw generateSyntaxError(`In ${tag}, ${modifier} is not a valid modifier`, mustache.loc);\n  }\n\n  const modifier = b.elementModifier({ path, params, hash, loc });\n  element.modifiers.push(modifier);\n}\n\nfunction repairBlock(\n  source: src.Source,\n  block: HBS.UpstreamBlockStatement,\n  fallbackStart: SourceSpan\n): HBS.BlockStatement {\n  // Extend till the beginning of the block\n  if (!block.program.loc) {\n    const start = block.program.body.at(0);\n    const end = block.program.body.at(-1);\n\n    if (start && end) {\n      block.program.loc = {\n        ...start.loc,\n        end: end.loc.end,\n      };\n    } else {\n      const loc = source.spanFor(block.loc);\n      block.program.loc = fallbackStart.withEnd(loc.getEnd());\n    }\n  }\n\n  let endProgram = source.spanFor(block.program.loc).getEnd();\n\n  if (block.inverse && !block.inverse.loc) {\n    block.inverse.loc = endProgram.collapsed();\n  }\n\n  return block as HBS.BlockStatement;\n}\n","import type { Nullable } from '@glimmer/interfaces';\nimport type { TokenizerState } from 'simple-html-tokenizer';\nimport {\n  asPresentArray,\n  assertPresentArray,\n  getFirst,\n  getLast,\n  isPresentArray,\n  localAssert,\n} from '@glimmer/debug-util';\nimport { assign } from '@glimmer/util';\nimport { parse, parseWithoutProcessing } from '@handlebars/parser';\nimport { EntityParser } from 'simple-html-tokenizer';\n\nimport type { EndTag, StartTag } from '../parser';\nimport type { NodeVisitor } from '../traversal/visitor';\nimport type * as ASTv1 from '../v1/api';\nimport type * as HBS from '../v1/handlebars-ast';\n\nimport print from '../generation/print';\nimport { voidMap } from '../generation/printer';\nimport * as src from '../source/api';\nimport { generateSyntaxError } from '../syntax-error';\nimport traverse from '../traversal/traverse';\nimport Walker from '../traversal/walker';\nimport { appendChild } from '../utils';\nimport b from '../v1/parser-builders';\nimport publicBuilder from '../v1/public-builders';\nimport { HandlebarsNodeVisitors } from './handlebars-node-visitors';\n\n// vendored from simple-html-tokenizer because it's unexported\nfunction isSpace(char: string): boolean {\n  return /[\\t\\n\\f ]/u.test(char);\n}\n\nexport class TokenizerEventHandlers extends HandlebarsNodeVisitors {\n  private tagOpenLine = 0;\n  private tagOpenColumn = 0;\n\n  reset(): void {\n    this.currentNode = null;\n  }\n\n  // Comment\n\n  beginComment(): void {\n    this.currentNode = {\n      type: 'CommentStatement',\n      value: '',\n      start: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn),\n    };\n  }\n\n  appendToCommentData(char: string): void {\n    this.currentComment.value += char;\n  }\n\n  finishComment(): void {\n    appendChild(this.currentElement(), b.comment(this.finish(this.currentComment)));\n  }\n\n  // Data\n\n  beginData(): void {\n    this.currentNode = {\n      type: 'TextNode',\n      chars: '',\n      start: this.offset(),\n    };\n  }\n\n  appendToData(char: string): void {\n    this.currentData.chars += char;\n  }\n\n  finishData(): void {\n    appendChild(this.currentElement(), b.text(this.finish(this.currentData)));\n  }\n\n  // Tags - basic\n\n  tagOpen(): void {\n    this.tagOpenLine = this.tokenizer.line;\n    this.tagOpenColumn = this.tokenizer.column;\n  }\n\n  beginStartTag(): void {\n    this.currentNode = {\n      type: 'StartTag',\n      name: '',\n      nameStart: null,\n      nameEnd: null,\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      params: [],\n      selfClosing: false,\n      start: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn),\n    };\n  }\n\n  beginEndTag(): void {\n    this.currentNode = {\n      type: 'EndTag',\n      name: '',\n      start: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn),\n    };\n  }\n\n  finishTag(): void {\n    let tag = this.finish<StartTag | EndTag>(this.currentTag);\n\n    if (tag.type === 'StartTag') {\n      this.finishStartTag();\n\n      if (tag.name === ':') {\n        throw generateSyntaxError(\n          'Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter',\n          this.source.spanFor({\n            start: this.currentTag.start.toJSON(),\n            end: this.offset().toJSON(),\n          })\n        );\n      }\n\n      if (voidMap.has(tag.name) || tag.selfClosing) {\n        this.finishEndTag(true);\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- exhaustive\n      localAssert(tag.type === 'EndTag', `Invalid tag type ${tag.type}`);\n      this.finishEndTag(false);\n    }\n  }\n\n  finishStartTag(): void {\n    let { name, nameStart, nameEnd } = this.currentStartTag;\n\n    // <> should probably be a syntax error, but s-h-t is currently broken for that case\n    localAssert(name !== '', 'tag name cannot be empty');\n    localAssert(nameStart !== null, 'nameStart unexpectedly null');\n    localAssert(nameEnd !== null, 'nameEnd unexpectedly null');\n\n    let nameLoc = nameStart.until(nameEnd);\n    let [head, ...tail] = asPresentArray(name.split('.'));\n    let path = b.path({\n      head: b.head({ original: head, loc: nameLoc.sliceStartChars({ chars: head.length }) }),\n      tail,\n      loc: nameLoc,\n    });\n\n    let { attributes, modifiers, comments, params, selfClosing, loc } = this.finish(\n      this.currentStartTag\n    );\n\n    let element = b.element({\n      path,\n      selfClosing,\n      attributes,\n      modifiers,\n      comments,\n      params,\n      children: [],\n      openTag: loc,\n      closeTag: selfClosing ? null : src.SourceSpan.broken(),\n      loc,\n    });\n    this.elementStack.push(element);\n  }\n\n  finishEndTag(isVoid: boolean): void {\n    let { start: closeTagStart } = this.currentTag;\n    let tag = this.finish<StartTag | EndTag>(this.currentTag);\n\n    let element = this.elementStack.pop() as ASTv1.ParentNode;\n\n    this.validateEndTag(tag, element, isVoid);\n    let parent = this.currentElement();\n\n    if (isVoid) {\n      element.closeTag = null;\n    } else if (element.selfClosing) {\n      localAssert(element.closeTag === null, 'element.closeTag unexpectedly present');\n    } else {\n      element.closeTag = closeTagStart.until(this.offset());\n    }\n\n    element.loc = element.loc.withEnd(this.offset());\n\n    appendChild(parent, b.element(element));\n  }\n\n  markTagAsSelfClosing(): void {\n    let tag = this.currentTag;\n\n    if (tag.type === 'StartTag') {\n      tag.selfClosing = true;\n    } else {\n      throw generateSyntaxError(\n        `Invalid end tag: closing tag must not be self-closing`,\n        this.source.spanFor({ start: tag.start.toJSON(), end: this.offset().toJSON() })\n      );\n    }\n  }\n\n  // Tags - name\n\n  appendToTagName(char: string): void {\n    let tag = this.currentTag;\n    tag.name += char;\n\n    if (tag.type === 'StartTag') {\n      let offset = this.offset();\n\n      if (tag.nameStart === null) {\n        localAssert(tag.nameEnd === null, 'nameStart and nameEnd must both be null');\n\n        // Note that the tokenizer already consumed the token here\n        tag.nameStart = offset.move(-1);\n      }\n\n      tag.nameEnd = offset;\n    }\n  }\n\n  // Tags - attributes\n\n  beginAttribute(): void {\n    let offset = this.offset();\n\n    this.currentAttribute = {\n      name: '',\n      parts: [],\n      currentPart: null,\n      isQuoted: false,\n      isDynamic: false,\n      start: offset,\n      valueSpan: offset.collapsed(),\n    };\n  }\n\n  appendToAttributeName(char: string): void {\n    this.currentAttr.name += char;\n\n    // The block params parsing code can actually handle peek=non-space just\n    // fine, but this check was added as an optimization, as there is a little\n    // bit of setup overhead for the parsing logic just to immediately bail\n    if (this.currentAttr.name === 'as') {\n      this.parsePossibleBlockParams();\n    }\n  }\n\n  beginAttributeValue(isQuoted: boolean): void {\n    this.currentAttr.isQuoted = isQuoted;\n    this.startTextPart();\n    this.currentAttr.valueSpan = this.offset().collapsed();\n  }\n\n  appendToAttributeValue(char: string): void {\n    let parts = this.currentAttr.parts;\n    let lastPart = parts[parts.length - 1];\n\n    let current = this.currentAttr.currentPart;\n\n    if (current) {\n      current.chars += char;\n\n      // update end location for each added char\n      current.loc = current.loc.withEnd(this.offset());\n    } else {\n      // initially assume the text node is a single char\n      let loc: src.SourceOffset = this.offset();\n\n      // the tokenizer line/column have already been advanced, correct location info\n      if (char === '\\n') {\n        loc = lastPart ? lastPart.loc.getEnd() : this.currentAttr.valueSpan.getStart();\n      } else {\n        loc = loc.move(-1);\n      }\n\n      this.currentAttr.currentPart = b.text({ chars: char, loc: loc.collapsed() });\n    }\n  }\n\n  finishAttributeValue(): void {\n    this.finalizeTextPart();\n\n    let tag = this.currentTag;\n    let tokenizerPos = this.offset();\n\n    if (tag.type === 'EndTag') {\n      throw generateSyntaxError(\n        `Invalid end tag: closing tag must not have attributes`,\n        this.source.spanFor({ start: tag.start.toJSON(), end: tokenizerPos.toJSON() })\n      );\n    }\n\n    let { name, parts, start, isQuoted, isDynamic, valueSpan } = this.currentAttr;\n\n    // Just trying to be helpful with `<Hello |foo|>` rather than letting it through as an attribute\n    if (name.startsWith('|') && parts.length === 0 && !isQuoted && !isDynamic) {\n      throw generateSyntaxError(\n        'Invalid block parameters syntax: block parameters must be preceded by the `as` keyword',\n        start.until(start.move(name.length))\n      );\n    }\n\n    let value = this.assembleAttributeValue(parts, isQuoted, isDynamic, start.until(tokenizerPos));\n    value.loc = valueSpan.withEnd(tokenizerPos);\n\n    let attribute = b.attr({ name, value, loc: start.until(tokenizerPos) });\n\n    this.currentStartTag.attributes.push(attribute);\n  }\n\n  private parsePossibleBlockParams() {\n    // const enums that we can't use directly\n    const BEFORE_ATTRIBUTE_NAME = 'beforeAttributeName' as TokenizerState.beforeAttributeName;\n    const ATTRIBUTE_NAME = 'attributeName' as TokenizerState.attributeName;\n    const AFTER_ATTRIBUTE_NAME = 'afterAttributeName' as TokenizerState.afterAttributeName;\n\n    // Regex to validate the identifier for block parameters.\n    // Based on the ID validation regex in Handlebars.\n\n    const ID_INVERSE_PATTERN = /[!\"#%&'()*+./;<=>@[\\\\\\]^`{|}~]/u;\n\n    type States = {\n      PossibleAs: { state: 'PossibleAs' };\n      BeforeStartPipe: { state: 'BeforeStartPipe' };\n      BeforeBlockParamName: { state: 'BeforeBlockParamName' };\n      BlockParamName: {\n        state: 'BlockParamName';\n        name: string;\n        start: src.SourceOffset;\n      };\n      AfterEndPipe: { state: 'AfterEndPipe' };\n      Error: {\n        state: 'Error';\n        message: string;\n        start: src.SourceOffset;\n      };\n      Done: { state: 'Done' };\n    };\n\n    type State = States[keyof States];\n\n    type Handler = (next: string) => void;\n\n    localAssert(this.tokenizer.state === ATTRIBUTE_NAME, 'must be in TokenizerState.attributeName');\n\n    const element = this.currentStartTag;\n    const as = this.currentAttr;\n\n    let state = { state: 'PossibleAs' } as State;\n\n    const handlers = {\n      PossibleAs: (next: string) => {\n        localAssert(state.state === 'PossibleAs', 'bug in block params parser');\n\n        if (isSpace(next)) {\n          // \" as ...\"\n          state = { state: 'BeforeStartPipe' };\n          this.tokenizer.transitionTo(AFTER_ATTRIBUTE_NAME);\n          this.tokenizer.consume();\n        } else if (next === '|') {\n          // \" as|...\"\n          // Following Handlebars and require a space between \"as\" and the pipe\n          throw generateSyntaxError(\n            `Invalid block parameters syntax: expecting at least one space character between \"as\" and \"|\"`,\n            as.start.until(this.offset().move(1))\n          );\n        } else {\n          // \" as{{...\", \" async...\", \" as=...\", \" as>...\", \" as/>...\"\n          // Don't consume, let the normal tokenizer code handle the next steps\n          state = { state: 'Done' };\n        }\n      },\n\n      BeforeStartPipe: (next: string) => {\n        localAssert(state.state === 'BeforeStartPipe', 'bug in block params parser');\n\n        if (isSpace(next)) {\n          this.tokenizer.consume();\n        } else if (next === '|') {\n          state = { state: 'BeforeBlockParamName' };\n          this.tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n          this.tokenizer.consume();\n        } else {\n          // \" as {{...\", \" as bs...\", \" as =...\", \" as ...\", \" as/>...\"\n          // Don't consume, let the normal tokenizer code handle the next steps\n          state = { state: 'Done' };\n        }\n      },\n\n      BeforeBlockParamName: (next: string) => {\n        localAssert(state.state === 'BeforeBlockParamName', 'bug in block params parser');\n\n        if (isSpace(next)) {\n          this.tokenizer.consume();\n        } else if (next === '') {\n          // The HTML tokenizer ran out of characters, so we are either\n          // encountering mustache or <EOF>\n          state = { state: 'Done' };\n          this.pendingError = {\n            mustache(loc: src.SourceSpan) {\n              throw generateSyntaxError(\n                `Invalid block parameters syntax: mustaches cannot be used inside parameters list`,\n                loc\n              );\n            },\n            eof(loc: src.SourceOffset) {\n              throw generateSyntaxError(\n                `Invalid block parameters syntax: expecting the tag to be closed with \">\" or \"/>\" after parameters list`,\n                as.start.until(loc)\n              );\n            },\n          };\n        } else if (next === '|') {\n          if (element.params.length === 0) {\n            // Following Handlebars and treat empty block params a syntax error\n            throw generateSyntaxError(\n              `Invalid block parameters syntax: empty parameters list, expecting at least one identifier`,\n              as.start.until(this.offset().move(1))\n            );\n          } else {\n            state = { state: 'AfterEndPipe' };\n            this.tokenizer.consume();\n          }\n        } else if (next === '>' || next === '/') {\n          throw generateSyntaxError(\n            `Invalid block parameters syntax: incomplete parameters list, expecting \"|\" but the tag was closed prematurely`,\n            as.start.until(this.offset().move(1))\n          );\n        } else {\n          // slurp up anything else into the name, validate later\n          state = {\n            state: 'BlockParamName',\n            name: next,\n            start: this.offset(),\n          };\n          this.tokenizer.consume();\n        }\n      },\n\n      BlockParamName: (next: string) => {\n        localAssert(state.state === 'BlockParamName', 'bug in block params parser');\n\n        if (next === '') {\n          // The HTML tokenizer ran out of characters, so we are either\n          // encountering mustache or <EOF>, HBS side will attach the error\n          // to the next span\n          state = { state: 'Done' };\n          this.pendingError = {\n            mustache(loc: src.SourceSpan) {\n              throw generateSyntaxError(\n                `Invalid block parameters syntax: mustaches cannot be used inside parameters list`,\n                loc\n              );\n            },\n            eof(loc: src.SourceOffset) {\n              throw generateSyntaxError(\n                `Invalid block parameters syntax: expecting the tag to be closed with \">\" or \"/>\" after parameters list`,\n                as.start.until(loc)\n              );\n            },\n          };\n        } else if (next === '|' || isSpace(next)) {\n          let loc = state.start.until(this.offset());\n\n          if (state.name === 'this' || ID_INVERSE_PATTERN.test(state.name)) {\n            throw generateSyntaxError(\n              `Invalid block parameters syntax: invalid identifier name \\`${state.name}\\``,\n              loc\n            );\n          }\n\n          element.params.push(b.var({ name: state.name, loc }));\n\n          state = next === '|' ? { state: 'AfterEndPipe' } : { state: 'BeforeBlockParamName' };\n          this.tokenizer.consume();\n        } else if (next === '>' || next === '/') {\n          throw generateSyntaxError(\n            `Invalid block parameters syntax: expecting \"|\" but the tag was closed prematurely`,\n            as.start.until(this.offset().move(1))\n          );\n        } else {\n          // slurp up anything else into the name, validate later\n          state.name += next;\n          this.tokenizer.consume();\n        }\n      },\n\n      AfterEndPipe: (next: string) => {\n        localAssert(state.state === 'AfterEndPipe', 'bug in block params parser');\n\n        if (isSpace(next)) {\n          this.tokenizer.consume();\n        } else if (next === '') {\n          // The HTML tokenizer ran out of characters, so we are either\n          // encountering mustache or <EOF>, HBS side will attach the error\n          // to the next span\n          state = { state: 'Done' };\n          this.pendingError = {\n            mustache(loc: src.SourceSpan) {\n              throw generateSyntaxError(\n                `Invalid block parameters syntax: modifiers cannot follow parameters list`,\n                loc\n              );\n            },\n            eof(loc: src.SourceOffset) {\n              throw generateSyntaxError(\n                `Invalid block parameters syntax: expecting the tag to be closed with \">\" or \"/>\" after parameters list`,\n                as.start.until(loc)\n              );\n            },\n          };\n        } else if (next === '>' || next === '/') {\n          // Don't consume, let the normal tokenizer code handle the next steps\n          state = { state: 'Done' };\n        } else {\n          // Slurp up the next \"token\" for the error span\n          state = {\n            state: 'Error',\n            message:\n              'Invalid block parameters syntax: expecting the tag to be closed with \">\" or \"/>\" after parameters list',\n            start: this.offset(),\n          };\n          this.tokenizer.consume();\n        }\n      },\n\n      Error: (next: string) => {\n        localAssert(state.state === 'Error', 'bug in block params parser');\n\n        if (next === '' || next === '/' || next === '>' || isSpace(next)) {\n          throw generateSyntaxError(state.message, state.start.until(this.offset()));\n        } else {\n          // Slurp up the next \"token\" for the error span\n          this.tokenizer.consume();\n        }\n      },\n\n      Done: () => {\n        localAssert(false, 'This should never be called');\n      },\n    } as const satisfies {\n      [S in keyof States]: Handler;\n    };\n\n    let next: string;\n\n    do {\n      next = this.tokenizer.peek();\n      handlers[state.state](next);\n    } while (state.state !== 'Done' && next !== '');\n\n    localAssert(state.state === 'Done', 'bug in block params parser');\n  }\n\n  reportSyntaxError(message: string): void {\n    throw generateSyntaxError(message, this.offset().collapsed());\n  }\n\n  assembleConcatenatedValue(\n    parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[]\n  ): ASTv1.ConcatStatement {\n    assertPresentArray(parts, `the concatenation parts of an element should not be empty`);\n\n    let first = getFirst(parts);\n    let last = getLast(parts);\n\n    return b.concat({\n      parts,\n      loc: this.source.spanFor(first.loc).extend(this.source.spanFor(last.loc)),\n    });\n  }\n\n  validateEndTag(\n    tag: StartTag | EndTag,\n    element: ASTv1.ParentNode,\n    selfClosing: boolean\n  ): asserts element is ASTv1.ElementNode {\n    if (voidMap.has(tag.name) && !selfClosing) {\n      // EngTag is also called by StartTag for void and self-closing tags (i.e.\n      // <input> or <br />, so we need to check for that here. Otherwise, we would\n      // throw an error for those cases.\n      throw generateSyntaxError(\n        `<${tag.name}> elements do not need end tags. You should remove it`,\n        tag.loc\n      );\n    } else if (element.type !== 'ElementNode') {\n      throw generateSyntaxError(`Closing tag </${tag.name}> without an open tag`, tag.loc);\n    } else if (element.tag !== tag.name) {\n      throw generateSyntaxError(\n        `Closing tag </${tag.name}> did not match last open tag <${element.tag}> (on line ${element.loc.startPosition.line})`,\n        tag.loc\n      );\n    }\n  }\n\n  assembleAttributeValue(\n    parts: ASTv1.AttrPart[],\n    isQuoted: boolean,\n    isDynamic: boolean,\n    span: src.SourceSpan\n  ): ASTv1.AttrValue {\n    if (isDynamic) {\n      if (isQuoted) {\n        return this.assembleConcatenatedValue(parts);\n      } else {\n        assertPresentArray(parts);\n\n        const [head, a] = parts;\n        if (a === undefined || (a.type === 'TextNode' && a.chars === '/')) {\n          return head;\n        } else {\n          throw generateSyntaxError(\n            `An unquoted attribute value must be a string or a mustache, ` +\n              `preceded by whitespace or a '=' character, and ` +\n              `followed by whitespace, a '>' character, or '/>'`,\n            span\n          );\n        }\n      }\n    } else if (isPresentArray(parts)) {\n      return parts[0];\n    } else {\n      return b.text({ chars: '', loc: span });\n    }\n  }\n}\n\n/**\n  ASTPlugins can make changes to the Glimmer template AST before\n  compilation begins.\n*/\nexport interface ASTPluginBuilder<TEnv extends ASTPluginEnvironment = ASTPluginEnvironment> {\n  (env: TEnv): ASTPlugin;\n}\n\nexport interface ASTPlugin {\n  name: string;\n  visitor: NodeVisitor;\n}\n\nexport interface ASTPluginEnvironment {\n  meta?: object | undefined;\n  syntax: Syntax;\n}\n\ninterface HandlebarsParseOptions {\n  srcName?: string;\n  ignoreStandalone?: boolean;\n}\n\nexport interface TemplateIdFn {\n  (src: string): Nullable<string>;\n}\n\nexport interface PrecompileOptions extends PreprocessOptions {\n  id?: TemplateIdFn;\n\n  /**\n   * Additional non-native keywords.\n   *\n   * Local variables (block params or lexical scope) always takes precedence,\n   * but otherwise, suitable free variable candidates (e.g. those are not part\n   * of a path) are matched against this list and turned into keywords.\n   *\n   * In strict mode compilation, keywords suppresses the undefined reference\n   * error and will be resolved by the runtime environment.\n   *\n   * In loose mode, keywords are currently ignored and since all free variables\n   * are already resolved by the runtime environment.\n   */\n  keywords?: readonly string[];\n\n  /**\n   * In loose mode, this hook allows embedding environments to customize the name of an\n   * angle-bracket component. In practice, this means that `<HelloWorld />` in Ember is\n   * compiled by Glimmer as an invocation of a component named `hello-world`.\n   *\n   * It's a little weird that this is needed in addition to the resolver, but it's a\n   * classic-only feature and it seems fine to leave it alone for classic consumers.\n   */\n  customizeComponentName?: ((input: string) => string) | undefined;\n}\n\nexport interface PrecompileOptionsWithLexicalScope extends PrecompileOptions {\n  lexicalScope: (variable: string) => boolean;\n\n  /**\n   * If `emit.debugSymbols` is set to `true`, the name of lexical local variables\n   * will be included in the wire format.\n   */\n  emit?:\n    | {\n        debugSymbols?: boolean;\n      }\n    | undefined;\n}\n\nexport interface PreprocessOptions {\n  strictMode?: boolean | undefined;\n  locals?: string[] | undefined;\n  meta?:\n    | {\n        moduleName?: string | undefined;\n      }\n    | undefined;\n  plugins?:\n    | {\n        ast?: ASTPluginBuilder[] | undefined;\n      }\n    | undefined;\n  parseOptions?: HandlebarsParseOptions | undefined;\n  customizeComponentName?: ((input: string) => string) | undefined;\n\n  /**\n    Useful for specifying a group of options together.\n\n    When `'codemod'` we disable all whitespace control in handlebars\n    (to preserve as much as possible) and we also avoid any\n    escaping/unescaping of HTML entity codes.\n   */\n  mode?: 'codemod' | 'precompile' | undefined;\n}\n\nexport interface Syntax {\n  parse: typeof preprocess;\n  builders: typeof publicBuilder;\n  print: typeof print;\n  traverse: typeof traverse;\n  Walker: typeof Walker;\n}\n\nconst syntax: Syntax = {\n  parse: preprocess,\n  builders: publicBuilder,\n  print,\n  traverse,\n  Walker,\n};\n\nclass CodemodEntityParser extends EntityParser {\n  // match upstream types, but never match an entity\n  constructor() {\n    super({});\n  }\n\n  override parse(): string | undefined {\n    return undefined;\n  }\n}\n\nexport function preprocess(\n  input: string | src.Source | HBS.Program,\n  options: PreprocessOptions = {}\n): ASTv1.Template {\n  let mode = options.mode || 'precompile';\n\n  let source: src.Source;\n  let ast: HBS.Program;\n  if (typeof input === 'string') {\n    source = new src.Source(input, options.meta?.moduleName);\n\n    if (mode === 'codemod') {\n      ast = parseWithoutProcessing(input, options.parseOptions) as HBS.Program;\n    } else {\n      ast = parse(input, options.parseOptions) as HBS.Program;\n    }\n  } else if (input instanceof src.Source) {\n    source = input;\n\n    if (mode === 'codemod') {\n      ast = parseWithoutProcessing(input.source, options.parseOptions) as HBS.Program;\n    } else {\n      ast = parse(input.source, options.parseOptions) as HBS.Program;\n    }\n  } else {\n    source = new src.Source('', options.meta?.moduleName);\n    ast = input;\n  }\n\n  let entityParser = undefined;\n  if (mode === 'codemod') {\n    entityParser = new CodemodEntityParser();\n  }\n\n  let offsets = src.SourceSpan.forCharPositions(source, 0, source.source.length);\n  ast.loc = {\n    source: '(program)',\n    start: offsets.startPosition,\n    end: offsets.endPosition,\n  };\n\n  let template = new TokenizerEventHandlers(source, entityParser, mode).parse(\n    ast,\n    options.locals ?? []\n  );\n\n  if (options.plugins?.ast) {\n    for (const transform of options.plugins.ast) {\n      let env: ASTPluginEnvironment = assign({}, options, { syntax }, { plugins: undefined });\n\n      let pluginResult = transform(env);\n\n      traverse(template, pluginResult.visitor);\n    }\n  }\n\n  return template;\n}\n","import type * as ASTv1 from './v1/api';\n\nimport { isKeyword } from './keywords';\nimport { preprocess } from './parser/tokenizer-event-handlers';\nimport traverse from './traversal/traverse';\n\ninterface GetTemplateLocalsOptions {\n  includeKeywords?: boolean;\n  includeHtmlElements?: boolean;\n}\n\n/**\n * Gets the correct Token from the Node based on it's type\n */\nfunction getPathName(\n  node: ASTv1.Node,\n  scopedTokens: string[],\n  options: GetTemplateLocalsOptions\n): string | void {\n  if (node.type === 'PathExpression') {\n    if (node.head.type === 'AtHead' || node.head.type === 'ThisHead') {\n      return;\n    }\n\n    const possbleToken = node.head.name;\n\n    if (scopedTokens.indexOf(possbleToken) === -1) {\n      return possbleToken;\n    }\n  } else if (node.type === 'ElementNode') {\n    const { tag } = node;\n\n    const char = tag.charAt(0);\n\n    if (char === ':' || char === '@') {\n      return;\n    }\n\n    if (!options.includeHtmlElements && tag.indexOf('.') === -1 && tag.toLowerCase() === tag) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-deprecated -- @fixme\n    if (tag.substr(0, 5) === 'this.') {\n      return;\n    }\n\n    // the tag may be from a yielded object\n    // example:\n    //   <x.button>\n    // An ElementNode does not parse the \"tag\" in to a PathExpression\n    // so we have to split on `.`, just like how `this` presence is checked.\n    if (tag.includes('.')) {\n      let [potentialLocal] = tag.split('.') as [string, ...string[]];\n\n      if (scopedTokens.includes(potentialLocal)) return;\n    }\n\n    if (scopedTokens.includes(tag)) return;\n\n    return tag;\n  }\n}\n\n/**\n * Adds tokens to the tokensSet based on their node.type\n */\nfunction addTokens(\n  tokensSet: Set<string>,\n  node: ASTv1.Node,\n  scopedTokens: string[],\n  options: GetTemplateLocalsOptions\n) {\n  const maybePathName = getPathName(node, scopedTokens, options);\n\n  if (maybePathName !== undefined && maybePathName[0] !== '@') {\n    const maybeFirstPathSegment = maybePathName.split('.')[0];\n    if (maybeFirstPathSegment && !scopedTokens.includes(maybeFirstPathSegment)) {\n      tokensSet.add(maybeFirstPathSegment);\n    }\n  }\n}\n\n/**\n * Parses and traverses a given handlebars html template to extract all template locals\n * referenced that could possible come from the parent scope. Can exclude known keywords\n * optionally.\n */\nexport function getTemplateLocals(\n  html: string,\n  options: GetTemplateLocalsOptions = {\n    includeHtmlElements: false,\n    includeKeywords: false,\n  }\n): string[] {\n  const ast = preprocess(html);\n  const tokensSet = new Set<string>();\n  const scopedTokens: string[] = [];\n\n  traverse(ast, {\n    Block: {\n      enter({ blockParams }) {\n        blockParams.forEach((param) => {\n          scopedTokens.push(param);\n        });\n      },\n\n      exit({ blockParams }) {\n        blockParams.forEach(() => {\n          scopedTokens.pop();\n        });\n      },\n    },\n\n    ElementNode: {\n      enter(node) {\n        node.blockParams.forEach((param) => {\n          scopedTokens.push(param);\n        });\n        addTokens(tokensSet, node, scopedTokens, options);\n      },\n\n      exit({ blockParams }) {\n        blockParams.forEach(() => {\n          scopedTokens.pop();\n        });\n      },\n    },\n\n    PathExpression(node) {\n      addTokens(tokensSet, node, scopedTokens, options);\n    },\n  });\n\n  let tokens: string[] = [];\n\n  tokensSet.forEach((s) => tokens.push(s));\n\n  if (!options.includeKeywords) {\n    tokens = tokens.filter((token) => !isKeyword(token));\n  }\n\n  return tokens;\n}\n","import { setLocalDebugType } from '@glimmer/debug-util';\nimport { assign } from '@glimmer/util';\n\nimport type { SourceSpan } from '../../source/span';\n\nexport interface BaseNodeFields {\n  loc: SourceSpan;\n}\n\n/**\n * This is a convenience function for creating ASTv2 nodes, with an optional name and the node's\n * options.\n *\n * ```ts\n * export class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}\n * ```\n *\n * This creates a new ASTv2 node with the name `'HtmlText'` and one field `chars: string` (in\n * addition to a `loc: SourceOffsets` field, which all nodes have).\n *\n * ```ts\n * export class Args extends node().fields<{\n *  positional: PositionalArguments;\n *  named: NamedArguments\n * }>() {}\n * ```\n *\n * This creates a new un-named ASTv2 node with two fields (`positional: Positional` and `named:\n * Named`, in addition to the generic `loc: SourceOffsets` field).\n *\n * Once you create a node using `node`, it is instantiated with all of its fields (including `loc`):\n *\n * ```ts\n * new HtmlText({ loc: offsets, chars: someString });\n * ```\n */\nexport function node(): {\n  fields<Fields extends object>(): NodeConstructor<Fields & BaseNodeFields>;\n};\nexport function node<T extends string>(\n  name: T\n): {\n  fields<Fields extends object>(): TypedNodeConstructor<T, Fields & BaseNodeFields>;\n};\n\nexport function node<T extends string>(\n  name?: T\n):\n  | {\n      fields<Fields extends object>(): TypedNodeConstructor<T, Fields & BaseNodeFields>;\n    }\n  | {\n      fields<Fields extends object>(): NodeConstructor<Fields & BaseNodeFields>;\n    } {\n  if (name !== undefined) {\n    const type = name;\n    return {\n      fields<Fields extends object>(): TypedNodeConstructor<T, BaseNodeFields & Fields> {\n        return class {\n          // SAFETY: initialized via `assign` in the constructor.\n          declare readonly loc: SourceSpan;\n          readonly type: T;\n\n          constructor(fields: BaseNodeFields & Fields) {\n            this.type = type;\n            assign(this, fields);\n\n            setLocalDebugType('syntax:mir:node', this);\n          }\n        } as TypedNodeConstructor<T, BaseNodeFields & Fields>;\n      },\n    };\n  } else {\n    return {\n      fields<Fields>(): NodeConstructor<Fields & BaseNodeFields> {\n        return class {\n          // SAFETY: initialized via `assign` in the constructor.\n          declare readonly loc: SourceSpan;\n\n          constructor(fields: BaseNodeFields & Fields) {\n            assign(this, fields);\n          }\n        } as NodeConstructor<BaseNodeFields & Fields>;\n      },\n    };\n  }\n}\n\nexport interface NodeConstructor<Fields> {\n  new (fields: Fields): Readonly<Fields>;\n}\n\ntype TypedNode<T extends string, Fields> = {\n  type: T;\n} & Readonly<Fields>;\n\nexport interface TypedNodeConstructor<T extends string, Fields> {\n  new (options: Fields): TypedNode<T, Fields>;\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { SourceSpan } from '../../source/span';\nimport type { ExpressionNode } from './expr';\n\nimport { node } from './node';\n\n/**\n * Corresponds to syntaxes with positional and named arguments:\n *\n * - SubExpression\n * - Invoking Append\n * - Invoking attributes\n * - InvokeBlock\n *\n * If `Args` is empty, the `SourceOffsets` for this node should be the collapsed position\n * immediately after the parent call node's `callee`.\n */\nexport class Args extends node().fields<{\n  positional: PositionalArguments;\n  named: NamedArguments;\n}>() {\n  static empty(loc: SourceSpan): Args {\n    return new Args({\n      loc,\n      positional: PositionalArguments.empty(loc),\n      named: NamedArguments.empty(loc),\n    });\n  }\n\n  static named(named: NamedArguments): Args {\n    return new Args({\n      loc: named.loc,\n      positional: PositionalArguments.empty(named.loc.collapse('end')),\n      named,\n    });\n  }\n\n  nth(offset: number): ExpressionNode | null {\n    return this.positional.nth(offset);\n  }\n\n  get(name: string): ExpressionNode | null {\n    return this.named.get(name);\n  }\n\n  isEmpty(): boolean {\n    return this.positional.isEmpty() && this.named.isEmpty();\n  }\n}\n\n/**\n * Corresponds to positional arguments.\n *\n * If `PositionalArguments` is empty, the `SourceOffsets` for this node should be the collapsed\n * position immediately after the parent call node's `callee`.\n */\nexport class PositionalArguments extends node().fields<{\n  exprs: readonly ExpressionNode[];\n}>() {\n  static empty(loc: SourceSpan): PositionalArguments {\n    return new PositionalArguments({\n      loc,\n      exprs: [],\n    });\n  }\n\n  get size(): number {\n    return this.exprs.length;\n  }\n\n  nth(offset: number): ExpressionNode | null {\n    return this.exprs[offset] || null;\n  }\n\n  isEmpty(): boolean {\n    return this.exprs.length === 0;\n  }\n}\n\n/**\n * Corresponds to named arguments.\n *\n * If `PositionalArguments` and `NamedArguments` are empty, the `SourceOffsets` for this node should\n * be the same as the `Args` node that contains this node.\n *\n * If `PositionalArguments` is not empty but `NamedArguments` is empty, the `SourceOffsets` for this\n * node should be the collapsed position immediately after the last positional argument.\n */\nexport class NamedArguments extends node().fields<{\n  entries: readonly NamedArgument[];\n}>() {\n  static empty(loc: SourceSpan): NamedArguments {\n    return new NamedArguments({\n      loc,\n      entries: [],\n    });\n  }\n\n  get size(): number {\n    return this.entries.length;\n  }\n\n  get(name: string): ExpressionNode | null {\n    let entry = this.entries.filter((e) => e.name.chars === name)[0];\n\n    return entry ? entry.value : null;\n  }\n\n  isEmpty(): boolean {\n    return this.entries.length === 0;\n  }\n}\n\n/**\n * Corresponds to a single named argument.\n *\n * ```hbs\n * x=<expr>\n * ```\n */\nexport class NamedArgument {\n  readonly loc: SourceSpan;\n  readonly name: SourceSlice;\n  readonly value: ExpressionNode;\n\n  constructor(options: { name: SourceSlice; value: ExpressionNode }) {\n    this.loc = options.name.loc.extend(options.value.loc);\n    this.name = options.name;\n    this.value = options.value;\n  }\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { CallFields } from './base';\nimport type { ExpressionNode } from './expr';\n\nimport { NamedArgument } from './args';\nimport { node } from './node';\n\n/**\n * Attr nodes look like HTML attributes, but are classified as:\n *\n * 1. `HtmlAttr`, which means a regular HTML attribute in Glimmer\n * 2. `SplatAttr`, which means `...attributes`\n * 3. `ComponentArg`, which means an attribute whose name begins with `@`, and it is therefore a\n *    component argument.\n */\nexport type AttrNode = HtmlAttr | SplatAttr | ComponentArg;\n\n/**\n * `HtmlAttr` and `SplatAttr` are grouped together because the order of the `SplatAttr` node,\n * relative to other attributes, matters.\n */\nexport type HtmlOrSplatAttr = HtmlAttr | SplatAttr;\n\n/**\n * \"Attr Block\" nodes are allowed inside an open element tag in templates. They interact with the\n * element (or component).\n */\nexport type AttrBlockNode = AttrNode | ElementModifier;\n\n/**\n * `HtmlAttr` nodes are valid HTML attributes, with or without a value.\n *\n * Exceptions:\n *\n * - `...attributes` is `SplatAttr`\n * - `@x=<value>` is `ComponentArg`\n */\nexport class HtmlAttr extends node('HtmlAttr').fields<AttrNodeOptions>() {}\n\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\n\n/**\n * Corresponds to an argument passed by a component (`@x=<value>`)\n */\nexport class ComponentArg extends node().fields<AttrNodeOptions>() {\n  /**\n   * Convert the component argument into a named argument node\n   */\n  toNamedArgument(): NamedArgument {\n    return new NamedArgument({\n      name: this.name,\n      value: this.value,\n    });\n  }\n}\n\n/**\n * An `ElementModifier` is just a normal call node in modifier position.\n */\nexport class ElementModifier extends node('ElementModifier').fields<CallFields>() {}\n\nexport interface AttrNodeOptions {\n  name: SourceSlice;\n  value: ExpressionNode;\n  trusting: boolean;\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { SymbolTable } from '../../symbol-table';\nimport type { ComponentArg, ElementModifier, HtmlOrSplatAttr } from './attr-block';\nimport type { CallFields } from './base';\nimport type { ExpressionNode } from './expr';\nimport type { NamedBlock, NamedBlocks } from './internal-node';\nimport type { BaseNodeFields } from './node';\n\nimport { SpanList } from '../../source/span-list';\nimport { Args, NamedArguments } from './args';\nimport { node } from './node';\n\n/**\n * Content Nodes are allowed in content positions in templates. They correspond to behavior in the\n * [Data][data] tokenization state in HTML.\n *\n * [data]: https://html.spec.whatwg.org/multipage/parsing.html#data-state\n */\nexport type ContentNode =\n  | HtmlText\n  | HtmlComment\n  | AppendContent\n  | InvokeBlock\n  | InvokeComponent\n  | SimpleElement\n  | GlimmerComment;\n\nexport class GlimmerComment extends node('GlimmerComment').fields<{ text: SourceSlice }>() {}\nexport class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}\nexport class HtmlComment extends node('HtmlComment').fields<{ text: SourceSlice }>() {}\n\nexport class AppendContent extends node('AppendContent').fields<{\n  value: ExpressionNode;\n  trusting: boolean;\n  table: SymbolTable;\n}>() {\n  get callee(): ExpressionNode {\n    if (this.value.type === 'Call') {\n      return this.value.callee;\n    } else {\n      return this.value;\n    }\n  }\n\n  get args(): Args {\n    if (this.value.type === 'Call') {\n      return this.value.args;\n    } else {\n      return Args.empty(this.value.loc.collapse('end'));\n    }\n  }\n}\n\nexport class InvokeBlock extends node('InvokeBlock').fields<\n  CallFields & { blocks: NamedBlocks }\n>() {}\n\ninterface InvokeComponentFields {\n  callee: ExpressionNode;\n  blocks: NamedBlocks;\n  attrs: readonly HtmlOrSplatAttr[];\n  componentArgs: readonly ComponentArg[];\n  modifiers: readonly ElementModifier[];\n}\n\n/**\n * Corresponds to a component invocation. When the content of a component invocation contains no\n * named blocks, `blocks` contains a single named block named `\"default\"`. When a component\n * invocation is self-closing, `blocks` is empty.\n */\nexport class InvokeComponent extends node('InvokeComponent').fields<InvokeComponentFields>() {\n  get args(): Args {\n    let entries = this.componentArgs.map((a) => a.toNamedArgument());\n\n    return Args.named(\n      new NamedArguments({\n        loc: SpanList.range(entries, this.callee.loc.collapse('end')),\n        entries,\n      })\n    );\n  }\n}\n\ninterface SimpleElementOptions extends BaseNodeFields {\n  tag: SourceSlice;\n  body: readonly ContentNode[];\n  attrs: readonly HtmlOrSplatAttr[];\n  componentArgs: readonly ComponentArg[];\n  modifiers: readonly ElementModifier[];\n}\n\n/**\n * Corresponds to a simple HTML element. The AST allows component arguments and modifiers to support\n * future extensions.\n */\nexport class SimpleElement extends node('SimpleElement').fields<SimpleElementOptions>() {\n  get args(): Args {\n    let entries = this.componentArgs.map((a) => a.toNamedArgument());\n\n    return Args.named(\n      new NamedArguments({\n        loc: SpanList.range(entries, this.tag.loc.collapse('end')),\n        entries,\n      })\n    );\n  }\n}\n\nexport type ElementNode = NamedBlock | InvokeComponent | SimpleElement;\n","import type { PresentArray } from '@glimmer/interfaces';\n\nimport type { CallFields } from './base';\nimport type { VariableReference } from './refs';\n\nimport { SourceSlice } from '../../source/slice';\nimport { node } from './node';\n\n/**\n * A Handlebars literal.\n *\n * {@link https://handlebarsjs.com/guide/expressions.html#literal-segments}\n */\nexport type LiteralValue = string | boolean | number | undefined | null;\n\nexport interface LiteralTypes {\n  string: string;\n  boolean: boolean;\n  number: number;\n  null: null;\n  undefined: undefined;\n}\n\n/**\n * Corresponds to a Handlebars literal.\n *\n * @see {LiteralValue}\n */\nexport class LiteralExpression extends node('Literal').fields<{ value: LiteralValue }>() {\n  toSlice(this: StringLiteral): SourceSlice {\n    return new SourceSlice({ loc: this.loc, chars: this.value });\n  }\n}\n\nexport type StringLiteral = LiteralExpression & { value: string };\n\n/**\n * Returns true if an input {@see ExpressionNode} is a literal.\n */\nexport function isLiteral<K extends keyof LiteralTypes = keyof LiteralTypes>(\n  node: ExpressionNode,\n  kind?: K\n): node is StringLiteral {\n  if (node.type === 'Literal') {\n    if (kind === undefined) {\n      return true;\n    } else if (kind === 'null') {\n      return node.value === null;\n    } else {\n      return typeof node.value === kind;\n    }\n  } else {\n    return false;\n  }\n}\n\n/**\n * Corresponds to a path in expression position.\n *\n * ```hbs\n * this\n * this.x\n * @x\n * @x.y\n * x\n * x.y\n * ```\n */\nexport class PathExpression extends node('Path').fields<{\n  ref: VariableReference;\n  tail: readonly SourceSlice[];\n}>() {}\n\n/**\n * Corresponds to a known strict-mode keyword. It behaves similarly to a\n * PathExpression with a FreeVarReference, but implies StrictResolution and\n * is guaranteed to not have a tail, since `{{outlet.foo}}` would have been\n * illegal.\n */\nexport class KeywordExpression extends node('Keyword').fields<{\n  name: string;\n  symbol: number;\n}>() {}\n\n/**\n * Corresponds to a parenthesized call expression.\n *\n * ```hbs\n * (x)\n * (x.y)\n * (x y)\n * (x.y z)\n * ```\n */\nexport class CallExpression extends node('Call').fields<CallFields>() {}\n\n/**\n * Corresponds to an interpolation in attribute value position.\n *\n * ```hbs\n * <a href=\"{{url}}.html\"\n * ```\n */\nexport class InterpolateExpression extends node('Interpolate').fields<{\n  parts: PresentArray<ExpressionNode>;\n}>() {}\n\nexport type ExpressionNode =\n  | LiteralExpression\n  | PathExpression\n  | KeywordExpression\n  | CallExpression\n  | InterpolateExpression;\n","import type { SourceSlice } from '../../source/slice';\nimport type { BlockSymbolTable, ProgramSymbolTable } from '../../symbol-table';\nimport type { ComponentArg, ElementModifier, HtmlOrSplatAttr } from './attr-block';\nimport type { GlimmerParentNodeOptions } from './base';\nimport type { BaseNodeFields } from './node';\n\nimport { SpanList } from '../../source/span-list';\nimport { Args, NamedArguments } from './args';\nimport { node } from './node';\n\n/**\n * Corresponds to an entire template.\n */\nexport class Template extends node().fields<\n  {\n    table: ProgramSymbolTable;\n  } & GlimmerParentNodeOptions\n>() {}\n\n/**\n * Represents a block. In principle this could be merged with `NamedBlock`, because all cases\n * involving blocks have at least a notional name.\n */\nexport class Block extends node().fields<\n  { scope: BlockSymbolTable } & GlimmerParentNodeOptions\n>() {}\n\n/**\n * Corresponds to a collection of named blocks.\n */\nexport class NamedBlocks extends node().fields<{ blocks: readonly NamedBlock[] }>() {\n  /**\n   * Get the `NamedBlock` for a given name.\n   */\n  get(name: 'default'): NamedBlock;\n  get(name: string): NamedBlock | null;\n  get(name: string): NamedBlock | null {\n    return this.blocks.filter((block) => block.name.chars === name)[0] || null;\n  }\n}\n\nexport interface NamedBlockFields extends BaseNodeFields {\n  name: SourceSlice;\n  block: Block;\n\n  // these are not currently supported, but are here for future expansion\n  attrs: readonly HtmlOrSplatAttr[];\n  componentArgs: readonly ComponentArg[];\n  modifiers: readonly ElementModifier[];\n}\n\n/**\n * Corresponds to a single named block. This is used for anonymous named blocks (`default` and\n * `else`).\n */\nexport class NamedBlock extends node().fields<NamedBlockFields>() {\n  get args(): Args {\n    let entries = this.componentArgs.map((a) => a.toNamedArgument());\n\n    return Args.named(\n      new NamedArguments({\n        loc: SpanList.range(entries, this.name.loc.collapse('end')),\n        entries,\n      })\n    );\n  }\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { FreeVarResolution } from './resolution';\n\nimport { node } from './node';\n\n/**\n * Corresponds to `this` at the head of an expression.\n */\nexport class ThisReference extends node('This').fields() {}\n\n/**\n * Corresponds to `@<ident>` at the beginning of an expression.\n */\nexport class ArgReference extends node('Arg').fields<{ name: SourceSlice; symbol: number }>() {}\n\n/**\n * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is in the current\n * block's scope.\n */\nexport class LocalVarReference extends node('Local').fields<{\n  name: string;\n  isTemplateLocal: boolean;\n  symbol: number;\n}>() {}\n\n/**\n * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is *not* in the\n * current block's scope.\n *\n * The `resolution: FreeVarResolution` field describes how to resolve the free variable.\n *\n * Note: In strict mode, it must always be a variable that is in a concrete JavaScript scope that\n * the template will be installed into.\n */\nexport class FreeVarReference extends node('Free').fields<{\n  name: string;\n  resolution: FreeVarResolution;\n  symbol: number;\n}>() {}\n\nexport type VariableReference = ThisReference | ArgReference | LocalVarReference | FreeVarReference;\n","/// FreeVarNamespace ///\n\nexport type HELPER_VAR_NS = 'Helper';\nexport const HELPER_VAR_NS: HELPER_VAR_NS = 'Helper';\nexport type MODIFIER_VAR_NS = 'Modifier';\nexport const MODIFIER_VAR_NS: MODIFIER_VAR_NS = 'Modifier';\nexport type COMPONENT_VAR_NS = 'Component';\nexport const COMPONENT_VAR_NS: COMPONENT_VAR_NS = 'Component';\n\nexport type FreeVarNamespace = HELPER_VAR_NS | MODIFIER_VAR_NS | COMPONENT_VAR_NS;\n","/**\n * A free variable is resolved according to a resolution rule:\n *\n * 1. Strict resolution\n * 2. Namespaced resolution\n */\n\nimport type { GetContextualFreeOpcode } from '@glimmer/interfaces';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { FreeVarNamespace } from './constants';\n\nimport { COMPONENT_VAR_NS, HELPER_VAR_NS, MODIFIER_VAR_NS } from './constants';\n\n/**\n * Strict resolution is used:\n *\n * 1. in a strict mode template\n * 2. in an local variable invocation with dot paths\n */\nexport const STRICT_RESOLUTION = {\n  resolution: (): GetContextualFreeOpcode => SexpOpcodes.GetStrictKeyword,\n  serialize: (): SerializedResolution => 'Strict',\n  isAngleBracket: false as const,\n};\n\nexport type StrictResolution = typeof STRICT_RESOLUTION;\n\nexport const HTML_RESOLUTION = {\n  ...STRICT_RESOLUTION,\n  isAngleBracket: true as const,\n};\n\nexport type HtmlResolution = typeof HTML_RESOLUTION;\n\nexport function isStrictResolution(value: unknown): value is StrictResolution {\n  return value === STRICT_RESOLUTION;\n}\n\n/**\n * A `LooseModeResolution` includes one or more namespaces to resolve the variable in\n *\n * In practice, there are a limited number of possible combinations of these degrees of freedom,\n * and they are captured by the `Namespaces` union below.\n */\nexport class LooseModeResolution {\n  /**\n   * Namespaced resolution is used in an unambiguous syntax position:\n   *\n   * 1. `(sexp)` (namespace: `Helper`)\n   * 2. `{{#block}}` (namespace: `Component`)\n   * 3. `<a {{modifier}}>` (namespace: `Modifier`)\n   * 4. `<Component />` (namespace: `Component`)\n   */\n  static namespaced(namespace: FreeVarNamespace, isAngleBracket = false): LooseModeResolution {\n    return new LooseModeResolution([namespace], isAngleBracket);\n  }\n\n  /**\n   * Append resolution is used when the variable should be resolved in both the `component` and\n   * `helper` namespaces.\n   *\n   * ```hbs\n   * {{x}}\n   * ```\n   *\n   * ```hbs\n   * {{x y}}\n   * ```\n   *\n   * ^ In either case, `x` should be resolved in the `component` and `helper` namespaces.\n   */\n  static append(): LooseModeResolution {\n    return new LooseModeResolution([COMPONENT_VAR_NS, HELPER_VAR_NS]);\n  }\n\n  /**\n   * Trusting append resolution is used when the variable should be resolved only in the\n   * `helper` namespaces.\n   *\n   * ```hbs\n   * {{{x}}}\n   * ```\n   *\n   * ```hbs\n   * {{{x y}}}\n   * ```\n   *\n   * ^ In either case, `x` should be resolved in the `helper` namespace.\n   */\n  static trustingAppend(): LooseModeResolution {\n    return this.namespaced(HELPER_VAR_NS);\n  }\n\n  constructor(\n    readonly namespaces: Namespaces,\n    readonly isAngleBracket = false\n  ) {}\n\n  resolution(): GetContextualFreeOpcode {\n    if (this.namespaces.length === 1) {\n      switch (this.namespaces[0]) {\n        case HELPER_VAR_NS:\n          return SexpOpcodes.GetFreeAsHelperHead;\n        case MODIFIER_VAR_NS:\n          return SexpOpcodes.GetFreeAsModifierHead;\n        case COMPONENT_VAR_NS:\n          return SexpOpcodes.GetFreeAsComponentHead;\n      }\n    } else {\n      return SexpOpcodes.GetFreeAsComponentOrHelperHead;\n    }\n  }\n\n  serialize(): SerializedResolution {\n    if (this.namespaces.length === 1) {\n      return this.namespaces[0];\n    } else {\n      return 'ComponentOrHelper';\n    }\n  }\n}\n\nexport const HELPER_NAMESPACE = HELPER_VAR_NS;\nexport const MODIFIER_NAMESPACE = MODIFIER_VAR_NS;\nexport const COMPONENT_NAMESPACE = COMPONENT_VAR_NS;\n\n/**\n * A `Namespaced` must be resolved in one or more namespaces.\n *\n * ```hbs\n * <X />\n * ```\n *\n * ^ `X` is resolved in the `component` namespace\n *\n * ```hbs\n * (x)\n * ```\n *\n * ^ `x` is resolved in the `helper` namespace\n *\n * ```hbs\n * <a {{x}} />\n * ```\n *\n * ^ `x` is resolved in the `modifier` namespace\n */\ntype Namespaces =\n  | [HELPER_VAR_NS]\n  | [MODIFIER_VAR_NS]\n  | [COMPONENT_VAR_NS]\n  | [COMPONENT_VAR_NS, HELPER_VAR_NS];\n\nexport type FreeVarResolution = StrictResolution | HtmlResolution | LooseModeResolution;\n\n// Serialization\nexport type SerializedResolution =\n  | 'Strict'\n  | 'Helper'\n  | 'Modifier'\n  | 'Component'\n  | 'ComponentOrHelper';\n\nexport function loadResolution(resolution: SerializedResolution): FreeVarResolution {\n  if (resolution === 'Strict') {\n    return STRICT_RESOLUTION;\n  } else if (resolution === 'ComponentOrHelper') {\n    return LooseModeResolution.append();\n  } else {\n    return LooseModeResolution.namespaced(resolution as FreeVarNamespace);\n  }\n}\n","import type { Core, Dict } from '@glimmer/interfaces';\nimport { setLocalDebugType, unwrap } from '@glimmer/debug-util';\nimport { dict } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport * as ASTv2 from './v2/api';\n\nexport interface Upvar {\n  readonly name: string;\n  readonly resolution: ASTv2.FreeVarResolution;\n}\n\ninterface SymbolTableOptions {\n  customizeComponentName: (input: string) => string;\n  lexicalScope: (variable: string) => boolean;\n}\n\nexport abstract class SymbolTable {\n  static top(\n    locals: readonly string[],\n    keywords: readonly string[],\n    options: SymbolTableOptions\n  ): ProgramSymbolTable {\n    return new ProgramSymbolTable(locals, keywords, options);\n  }\n\n  abstract root(): ProgramSymbolTable;\n\n  abstract has(name: string): boolean;\n  abstract get(name: string): [symbol: number, isRoot: boolean];\n\n  abstract hasKeyword(name: string): boolean;\n  abstract getKeyword(name: string): number;\n\n  abstract hasLexical(name: string): boolean;\n\n  abstract getLocalsMap(): Dict<number>;\n  abstract getDebugInfo(): Core.DebugSymbols;\n\n  abstract allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;\n  abstract allocateNamed(name: string): number;\n  abstract allocateBlock(name: string): number;\n  abstract allocate(identifier: string): number;\n\n  child(locals: string[]): BlockSymbolTable {\n    let symbols = locals.map((name) => this.allocate(name));\n    return new BlockSymbolTable(this, locals, symbols);\n  }\n}\n\nexport class ProgramSymbolTable extends SymbolTable {\n  constructor(\n    private templateLocals: readonly string[],\n    private keywords: readonly string[],\n    private options: SymbolTableOptions\n  ) {\n    super();\n\n    setLocalDebugType('syntax:symbol-table:program', this, {\n      debug: () => ({\n        templateLocals: this.templateLocals,\n        keywords: this.keywords,\n        symbols: this.symbols,\n        upvars: this.upvars,\n        named: this.named,\n        blocks: this.blocks,\n      }),\n    });\n  }\n\n  readonly symbols: string[] = [];\n  readonly upvars: string[] = [];\n\n  private size = 1;\n  readonly named = dict<number>();\n  readonly blocks = dict<number>();\n  readonly usedTemplateLocals: string[] = [];\n\n  root(): this {\n    return this;\n  }\n\n  hasLexical(name: string): boolean {\n    return this.options.lexicalScope(name);\n  }\n\n  hasKeyword(name: string): boolean {\n    return this.keywords.includes(name);\n  }\n\n  getKeyword(name: string): number {\n    return this.allocateFree(name, ASTv2.STRICT_RESOLUTION);\n  }\n\n  getUsedTemplateLocals(): string[] {\n    return this.usedTemplateLocals;\n  }\n\n  has(name: string): boolean {\n    return this.templateLocals.includes(name);\n  }\n\n  get(name: string): [number, boolean] {\n    let index = this.usedTemplateLocals.indexOf(name);\n\n    if (index !== -1) {\n      return [index, true];\n    }\n\n    index = this.usedTemplateLocals.length;\n    this.usedTemplateLocals.push(name);\n    return [index, true];\n  }\n\n  getLocalsMap(): Dict<number> {\n    return dict();\n  }\n\n  getDebugInfo(): Core.DebugSymbols {\n    return [this.getLocalsMap(), this.named];\n  }\n\n  allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number {\n    // If the name in question is an uppercase (i.e. angle-bracket) component invocation, run\n    // the optional `customizeComponentName` function provided to the precompiler.\n    if (\n      resolution.resolution() === SexpOpcodes.GetFreeAsComponentHead &&\n      resolution.isAngleBracket\n    ) {\n      name = this.options.customizeComponentName(name);\n    }\n\n    let index = this.upvars.indexOf(name);\n\n    if (index !== -1) {\n      return index;\n    }\n\n    index = this.upvars.length;\n    this.upvars.push(name);\n    return index;\n  }\n\n  allocateNamed(name: string): number {\n    let named = this.named[name];\n\n    if (!named) {\n      named = this.named[name] = this.allocate(name);\n    }\n\n    return named;\n  }\n\n  allocateBlock(name: string): number {\n    if (name === 'inverse') {\n      name = 'else';\n    }\n\n    let block = this.blocks[name];\n\n    if (!block) {\n      block = this.blocks[name] = this.allocate(`&${name}`);\n    }\n\n    return block;\n  }\n\n  allocate(identifier: string): number {\n    this.symbols.push(identifier);\n    return this.size++;\n  }\n}\n\nexport class BlockSymbolTable extends SymbolTable {\n  constructor(\n    private parent: SymbolTable,\n    public symbols: string[],\n    public slots: number[]\n  ) {\n    super();\n  }\n\n  root(): ProgramSymbolTable {\n    return this.parent.root();\n  }\n\n  get locals(): string[] {\n    return this.symbols;\n  }\n\n  hasLexical(name: string): boolean {\n    return this.parent.hasLexical(name);\n  }\n\n  getKeyword(name: string): number {\n    return this.parent.getKeyword(name);\n  }\n\n  hasKeyword(name: string): boolean {\n    return this.parent.hasKeyword(name);\n  }\n\n  has(name: string): boolean {\n    return this.symbols.indexOf(name) !== -1 || this.parent.has(name);\n  }\n\n  get(name: string): [number, boolean] {\n    let local = this.#get(name);\n    return local ? [local, false] : this.parent.get(name);\n  }\n\n  #get(name: string): number | null {\n    let slot = this.symbols.indexOf(name);\n    return slot === -1 ? null : unwrap(this.slots[slot]);\n  }\n\n  getLocalsMap(): Dict<number> {\n    let dict = this.parent.getLocalsMap();\n    this.symbols.forEach((symbol) => (dict[symbol] = this.get(symbol)[0]));\n    return dict;\n  }\n\n  getDebugInfo(): [locals: Record<string, number>, upvars: Record<string, number>] {\n    const locals = this.getLocalsMap();\n    const root = this.root();\n    const named = root.named;\n\n    return [{ ...locals, ...named }, Object.fromEntries(root.upvars.map((s, i) => [s, i]))];\n  }\n\n  allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number {\n    return this.parent.allocateFree(name, resolution);\n  }\n\n  allocateNamed(name: string): number {\n    return this.parent.allocateNamed(name);\n  }\n\n  allocateBlock(name: string): number {\n    return this.parent.allocateBlock(name);\n  }\n\n  allocate(identifier: string): number {\n    return this.parent.allocate(identifier);\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { assertPresentArray, localAssert } from '@glimmer/debug-util';\nimport { assign } from '@glimmer/util';\n\nimport type { SourceSpan } from '../source/span';\nimport type { BlockSymbolTable, ProgramSymbolTable, SymbolTable } from '../symbol-table';\n\nimport { SourceSlice } from '../source/slice';\nimport { SpanList } from '../source/span-list';\nimport * as ASTv2 from './api';\n\nexport interface CallParts {\n  callee: ASTv2.CalleeNode;\n  args: ASTv2.Args;\n}\n\nexport class Builder {\n  // TEMPLATE //\n\n  template(\n    symbols: ProgramSymbolTable,\n    body: ASTv2.ContentNode[],\n    loc: SourceSpan\n  ): ASTv2.Template {\n    return new ASTv2.Template({\n      table: symbols,\n      body,\n      loc,\n    });\n  }\n\n  // INTERNAL (these nodes cannot be reached when doing general-purpose visiting) //\n\n  block(symbols: BlockSymbolTable, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.Block {\n    return new ASTv2.Block({\n      scope: symbols,\n      body,\n      loc,\n    });\n  }\n\n  namedBlock(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock {\n    return new ASTv2.NamedBlock({\n      name,\n      block,\n      attrs: [],\n      componentArgs: [],\n      modifiers: [],\n      loc,\n    });\n  }\n\n  simpleNamedBlock(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock {\n    return new BuildElement({\n      selfClosing: false,\n      attrs: [],\n      componentArgs: [],\n      modifiers: [],\n      comments: [],\n    }).named(name, block, loc);\n  }\n\n  slice(chars: string, loc: SourceSpan): SourceSlice {\n    return new SourceSlice({\n      loc,\n      chars,\n    });\n  }\n\n  args(\n    positional: ASTv2.PositionalArguments,\n    named: ASTv2.NamedArguments,\n    loc: SourceSpan\n  ): ASTv2.Args {\n    return new ASTv2.Args({\n      loc,\n      positional,\n      named,\n    });\n  }\n\n  positional(exprs: ASTv2.ExpressionNode[], loc: SourceSpan): ASTv2.PositionalArguments {\n    return new ASTv2.PositionalArguments({\n      loc,\n      exprs,\n    });\n  }\n\n  namedArgument(key: SourceSlice, value: ASTv2.ExpressionNode): ASTv2.NamedArgument {\n    return new ASTv2.NamedArgument({\n      name: key,\n      value,\n    });\n  }\n\n  named(entries: ASTv2.NamedArgument[], loc: SourceSpan): ASTv2.NamedArguments {\n    return new ASTv2.NamedArguments({\n      loc,\n      entries,\n    });\n  }\n\n  attr(\n    {\n      name,\n      value,\n      trusting,\n    }: { name: SourceSlice; value: ASTv2.ExpressionNode; trusting: boolean },\n    loc: SourceSpan\n  ): ASTv2.HtmlAttr {\n    return new ASTv2.HtmlAttr({\n      loc,\n      name,\n      value,\n      trusting,\n    });\n  }\n\n  splatAttr(symbol: number, loc: SourceSpan): ASTv2.SplatAttr {\n    return new ASTv2.SplatAttr({\n      symbol,\n      loc,\n    });\n  }\n\n  arg(\n    {\n      name,\n      value,\n      trusting,\n    }: { name: SourceSlice; value: ASTv2.ExpressionNode; trusting: boolean },\n    loc: SourceSpan\n  ): ASTv2.ComponentArg {\n    return new ASTv2.ComponentArg({\n      name,\n      value,\n      trusting,\n      loc,\n    });\n  }\n\n  // EXPRESSIONS //\n\n  path(head: ASTv2.VariableReference, tail: SourceSlice[], loc: SourceSpan): ASTv2.PathExpression {\n    return new ASTv2.PathExpression({\n      loc,\n      ref: head,\n      tail,\n    });\n  }\n\n  keyword(name: string, symbol: number, loc: SourceSpan): ASTv2.KeywordExpression {\n    return new ASTv2.KeywordExpression({\n      loc,\n      name,\n      symbol,\n    });\n  }\n\n  self(loc: SourceSpan): ASTv2.VariableReference {\n    return new ASTv2.ThisReference({\n      loc,\n    });\n  }\n\n  at(name: string, symbol: number, loc: SourceSpan): ASTv2.VariableReference {\n    // the `@` should be included so we have a complete source range\n    localAssert(name[0] === '@', `call builders.at() with a string that starts with '@'`);\n\n    return new ASTv2.ArgReference({\n      loc,\n      name: new SourceSlice({ loc, chars: name }),\n      symbol,\n    });\n  }\n\n  freeVar({\n    name,\n    context,\n    symbol,\n    loc,\n  }: {\n    name: string;\n    context: ASTv2.FreeVarResolution;\n    symbol: number;\n    loc: SourceSpan;\n  }): ASTv2.FreeVarReference {\n    localAssert(\n      name !== 'this',\n      `You called builders.freeVar() with 'this'. Call builders.this instead`\n    );\n    localAssert(\n      name[0] !== '@',\n      `You called builders.freeVar() with '${name}'. Call builders.at('${name}') instead`\n    );\n\n    return new ASTv2.FreeVarReference({\n      name,\n      resolution: context,\n      symbol,\n      loc,\n    });\n  }\n\n  localVar(\n    name: string,\n    symbol: number,\n    isTemplateLocal: boolean,\n    loc: SourceSpan\n  ): ASTv2.VariableReference {\n    localAssert(\n      name[0] !== '@',\n      `You called builders.var() with '${name}'. Call builders.at('${name}') instead`\n    );\n\n    return new ASTv2.LocalVarReference({\n      loc,\n      name,\n      isTemplateLocal,\n      symbol,\n    });\n  }\n\n  sexp(parts: CallParts, loc: SourceSpan): ASTv2.CallExpression {\n    return new ASTv2.CallExpression({\n      loc,\n      callee: parts.callee,\n      args: parts.args,\n    });\n  }\n\n  interpolate(parts: ASTv2.ExpressionNode[], loc: SourceSpan): ASTv2.InterpolateExpression {\n    assertPresentArray(parts);\n\n    return new ASTv2.InterpolateExpression({\n      loc,\n      parts,\n    });\n  }\n\n  literal(value: string, loc: SourceSpan): ASTv2.LiteralExpression & { value: string };\n  literal(value: number, loc: SourceSpan): ASTv2.LiteralExpression & { value: number };\n  literal(value: boolean, loc: SourceSpan): ASTv2.LiteralExpression & { value: boolean };\n  literal(value: null, loc: SourceSpan): ASTv2.LiteralExpression & { value: null };\n  literal(value: undefined, loc: SourceSpan): ASTv2.LiteralExpression & { value: undefined };\n  literal(\n    value: string | number | boolean | null | undefined,\n    loc: SourceSpan\n  ): ASTv2.LiteralExpression;\n  literal(\n    value: string | number | boolean | null | undefined,\n    loc: SourceSpan\n  ): ASTv2.LiteralExpression {\n    return new ASTv2.LiteralExpression({\n      loc,\n      value,\n    });\n  }\n\n  // STATEMENTS //\n\n  append(\n    {\n      table,\n      trusting,\n      value,\n    }: { table: SymbolTable; trusting: boolean; value: ASTv2.ExpressionNode },\n    loc: SourceSpan\n  ): ASTv2.AppendContent {\n    return new ASTv2.AppendContent({\n      table,\n      trusting,\n      value,\n      loc,\n    });\n  }\n\n  modifier({ callee, args }: CallParts, loc: SourceSpan): ASTv2.ElementModifier {\n    return new ASTv2.ElementModifier({\n      loc,\n      callee,\n      args,\n    });\n  }\n\n  namedBlocks(blocks: ASTv2.NamedBlock[], loc: SourceSpan): ASTv2.NamedBlocks {\n    return new ASTv2.NamedBlocks({\n      loc,\n      blocks,\n    });\n  }\n\n  blockStatement(\n    {\n      program,\n      inverse = null,\n      ...call\n    }: {\n      symbols: SymbolTable;\n      program: ASTv2.Block;\n      inverse?: ASTv2.Block | null;\n    } & CallParts,\n    loc: SourceSpan\n  ): ASTv2.InvokeBlock {\n    let blocksLoc = program.loc;\n    let blocks: PresentArray<ASTv2.NamedBlock> = [\n      this.namedBlock(SourceSlice.synthetic('default'), program, program.loc),\n    ];\n    if (inverse) {\n      blocksLoc = blocksLoc.extend(inverse.loc);\n      blocks.push(this.namedBlock(SourceSlice.synthetic('else'), inverse, inverse.loc));\n    }\n\n    return new ASTv2.InvokeBlock({\n      loc,\n      blocks: this.namedBlocks(blocks, blocksLoc),\n      callee: call.callee,\n      args: call.args,\n    });\n  }\n\n  element(options: BuildBaseElement): BuildElement {\n    return new BuildElement(options);\n  }\n}\n\nexport interface BuildBaseElement {\n  selfClosing: boolean;\n  attrs: ASTv2.HtmlOrSplatAttr[];\n  componentArgs: ASTv2.ComponentArg[];\n  modifiers: ASTv2.ElementModifier[];\n  comments: ASTv2.GlimmerComment[];\n}\n\nexport class BuildElement {\n  readonly builder: Builder;\n  constructor(readonly base: BuildBaseElement) {\n    this.builder = new Builder();\n  }\n\n  simple(tag: SourceSlice, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.SimpleElement {\n    return new ASTv2.SimpleElement(\n      assign(\n        {\n          tag,\n          body,\n          componentArgs: [],\n          loc,\n        },\n        this.base\n      )\n    );\n  }\n\n  named(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock {\n    return new ASTv2.NamedBlock(\n      assign(\n        {\n          name,\n          block,\n          componentArgs: [],\n          loc,\n        },\n        this.base\n      )\n    );\n  }\n\n  selfClosingComponent(callee: ASTv2.ExpressionNode, loc: SourceSpan): ASTv2.InvokeComponent {\n    return new ASTv2.InvokeComponent(\n      assign(\n        {\n          loc,\n          callee,\n          // point the empty named blocks at the `/` self-closing tag\n          blocks: new ASTv2.NamedBlocks({\n            blocks: [],\n            loc: loc.sliceEndChars({ skipEnd: 1, chars: 1 }),\n          }),\n        },\n        this.base\n      )\n    );\n  }\n\n  componentWithDefaultBlock(\n    callee: ASTv2.ExpressionNode,\n    children: ASTv2.ContentNode[],\n    symbols: BlockSymbolTable,\n    loc: SourceSpan\n  ): ASTv2.InvokeComponent {\n    let block = this.builder.block(symbols, children, loc);\n    let namedBlock = this.builder.namedBlock(SourceSlice.synthetic('default'), block, loc); // BUILDER.simpleNamedBlock('default', children, symbols, loc);\n\n    return new ASTv2.InvokeComponent(\n      assign(\n        {\n          loc,\n          callee,\n          blocks: this.builder.namedBlocks([namedBlock], namedBlock.loc),\n        },\n        this.base\n      )\n    );\n  }\n\n  componentWithNamedBlocks(\n    callee: ASTv2.ExpressionNode,\n    blocks: PresentArray<ASTv2.NamedBlock>,\n    loc: SourceSpan\n  ): ASTv2.InvokeComponent {\n    return new ASTv2.InvokeComponent(\n      assign(\n        {\n          loc,\n          callee,\n          blocks: this.builder.namedBlocks(blocks, SpanList.range(blocks)),\n        },\n        this.base\n      )\n    );\n  }\n}\n","import type * as ASTv1 from '../v1/api';\n\nimport * as ASTv2 from './api';\n\nexport interface AstCallParts {\n  path: ASTv1.Expression;\n  params: ASTv1.Expression[];\n  hash: ASTv1.Hash;\n}\n\nexport interface VarPath extends ASTv1.PathExpression {\n  head: ASTv1.VarHead;\n}\n\nexport function SexpSyntaxContext(node: ASTv1.SubExpression): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.HELPER_NAMESPACE);\n  } else {\n    return null;\n  }\n}\n\nexport function ModifierSyntaxContext(\n  node: ASTv1.ElementModifierStatement\n): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.MODIFIER_NAMESPACE);\n  } else {\n    return null;\n  }\n}\n\nexport function BlockSyntaxContext(node: ASTv1.BlockStatement): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.COMPONENT_NAMESPACE);\n  } else {\n    return null;\n  }\n}\n\nexport function ComponentSyntaxContext(node: ASTv1.PathExpression): ASTv2.FreeVarResolution | null {\n  if (isSimplePath(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.COMPONENT_NAMESPACE, true);\n  } else {\n    return null;\n  }\n}\n\n/**\n * This corresponds to attribute curlies (<Foo bar={{...}}>).\n * In strict mode, this also corresponds to arg curlies.\n */\nexport function AttrValueSyntaxContext(\n  node: ASTv1.MustacheStatement\n): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.HELPER_NAMESPACE);\n  } else {\n    return null;\n  }\n}\n\n/**\n * This corresponds to append positions text curlies.\n */\nexport function AppendSyntaxContext(node: ASTv1.MustacheStatement): ASTv2.FreeVarResolution | null {\n  let isSimple = isSimpleCallee(node);\n  let trusting = node.trusting;\n\n  if (isSimple) {\n    return trusting\n      ? ASTv2.LooseModeResolution.trustingAppend()\n      : ASTv2.LooseModeResolution.append();\n  } else {\n    return null;\n  }\n}\n\nexport type Resolution<P extends AstCallParts | ASTv1.PathExpression> = (\n  call: P\n) => ASTv2.FreeVarResolution | null;\n\n// UTILITIES\n\n/**\n * A call node has a simple callee if its head is:\n *\n * - a `PathExpression`\n * - the `PathExpression`'s head is a `VarHead`\n * - it has no tail\n *\n * Simple heads:\n *\n * ```\n * {{x}}\n * {{x y}}\n * ```\n *\n * Not simple heads:\n *\n * ```\n * {{x.y}}\n * {{x.y z}}\n * {{@x}}\n * {{@x a}}\n * {{this}}\n * {{this a}}\n * ```\n */\nfunction isSimpleCallee(node: AstCallParts): boolean {\n  return isSimplePath(node.path);\n}\n\ntype SimplePath = ASTv1.PathExpression & { head: ASTv1.VarHead };\n\nfunction isSimplePath(node: ASTv1.Expression): node is SimplePath {\n  if (node.type === 'PathExpression' && node.head.type === 'VarHead') {\n    return node.tail.length === 0;\n  } else {\n    return false;\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { asPresentArray, isPresentArray, localAssert } from '@glimmer/debug-util';\nimport { assign } from '@glimmer/util';\n\nimport type {\n  PrecompileOptions,\n  PrecompileOptionsWithLexicalScope,\n} from '../parser/tokenizer-event-handlers';\nimport type { SourceLocation } from '../source/location';\nimport type { Source } from '../source/source';\nimport type { SourceSpan } from '../source/span';\nimport type { BlockSymbolTable, ProgramSymbolTable } from '../symbol-table';\nimport type * as ASTv1 from '../v1/api';\nimport type { BuildElement, CallParts } from './builders';\nimport type { Resolution } from './loose-resolution';\n\nimport Printer from '../generation/printer';\nimport { preprocess } from '../parser/tokenizer-event-handlers';\nimport { SourceSlice } from '../source/slice';\nimport { SpanList } from '../source/span-list';\nimport { SymbolTable } from '../symbol-table';\nimport { generateSyntaxError } from '../syntax-error';\nimport { isLowerCase, isUpperCase } from '../utils';\nimport b from '../v1/parser-builders';\nimport * as ASTv2 from './api';\nimport { Builder } from './builders';\nimport {\n  AppendSyntaxContext,\n  AttrValueSyntaxContext,\n  BlockSyntaxContext,\n  ComponentSyntaxContext,\n  ModifierSyntaxContext,\n  SexpSyntaxContext,\n} from './loose-resolution';\n\nexport function normalize(\n  source: Source,\n  options: PrecompileOptionsWithLexicalScope = { lexicalScope: () => false }\n): [ast: ASTv2.Template, locals: string[]] {\n  let ast = preprocess(source, options);\n\n  let normalizeOptions = {\n    strictMode: false,\n    ...options,\n    locals: ast.blockParams,\n    keywords: options.keywords ?? [],\n  };\n\n  let top = SymbolTable.top(normalizeOptions.locals, normalizeOptions.keywords, {\n    customizeComponentName: options.customizeComponentName ?? ((name) => name),\n    lexicalScope: options.lexicalScope,\n  });\n  let block = new BlockContext(source, normalizeOptions, top);\n  let normalizer = new StatementNormalizer(block);\n\n  let astV2 = new TemplateChildren(\n    block.loc(ast.loc),\n    ast.body.map((b) => normalizer.normalize(b)),\n    block\n  ).assertTemplate(top);\n\n  let locals = top.getUsedTemplateLocals();\n\n  return [astV2, locals];\n}\n\n/**\n * A `BlockContext` represents the block that a particular AST node is contained inside of.\n *\n * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings\n * that are in-scope within that block.\n *\n * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides\n * facilities for working with those options.\n *\n * `BlockContext` is stateless.\n */\nexport class BlockContext<Table extends SymbolTable = SymbolTable> {\n  readonly builder: Builder;\n\n  constructor(\n    readonly source: Source,\n    private readonly options: PrecompileOptions,\n    readonly table: Table\n  ) {\n    this.builder = new Builder();\n  }\n\n  get strict(): boolean {\n    return this.options.strictMode || false;\n  }\n\n  loc(loc: SourceLocation): SourceSpan {\n    return this.source.spanFor(loc);\n  }\n\n  resolutionFor<N extends ASTv1.CallNode | ASTv1.PathExpression>(\n    node: N,\n    resolution: Resolution<N>\n  ): { result: ASTv2.FreeVarResolution } | { result: 'error'; path: string; head: string } {\n    if (this.strict) {\n      return { result: ASTv2.STRICT_RESOLUTION };\n    }\n\n    if (this.isFreeVar(node)) {\n      let r = resolution(node);\n\n      if (r === null) {\n        return {\n          result: 'error',\n          path: printPath(node),\n          head: printHead(node),\n        };\n      }\n\n      return { result: r };\n    } else {\n      return { result: ASTv2.STRICT_RESOLUTION };\n    }\n  }\n\n  isLexicalVar(variable: string): boolean {\n    return this.table.hasLexical(variable);\n  }\n\n  isKeyword(name: string): boolean {\n    return this.strict && !this.table.hasLexical(name) && this.table.hasKeyword(name);\n  }\n\n  private isFreeVar(callee: ASTv1.CallNode | ASTv1.PathExpression): boolean {\n    if (callee.type === 'PathExpression') {\n      if (callee.head.type !== 'VarHead') {\n        return false;\n      }\n\n      return !this.table.has(callee.head.name);\n    } else if (callee.path.type === 'PathExpression') {\n      return this.isFreeVar(callee.path);\n    } else {\n      return false;\n    }\n  }\n\n  hasBinding(name: string): boolean {\n    return this.table.has(name) || this.table.hasLexical(name);\n  }\n\n  child(blockParams: string[]): BlockContext<BlockSymbolTable> {\n    return new BlockContext(this.source, this.options, this.table.child(blockParams));\n  }\n\n  customizeComponentName(input: string): string {\n    if (this.options.customizeComponentName) {\n      return this.options.customizeComponentName(input);\n    } else {\n      return input;\n    }\n  }\n}\n\n/**\n * An `ExpressionNormalizer` normalizes expressions within a block.\n *\n * `ExpressionNormalizer` is stateless.\n */\nclass ExpressionNormalizer {\n  constructor(private block: BlockContext) {}\n\n  /**\n   * The `normalize` method takes an arbitrary expression and its original syntax context and\n   * normalizes it to an ASTv2 expression.\n   *\n   * @see {SyntaxContext}\n   */\n  normalize(expr: ASTv1.Literal): ASTv2.LiteralExpression;\n  normalize(expr: ASTv1.SubExpression): ASTv2.CallExpression;\n  normalize(\n    expr: ASTv1.MinimalPathExpression,\n    resolution: ASTv2.FreeVarResolution\n  ): ASTv2.PathExpression;\n  normalize(expr: ASTv1.Expression, resolution: ASTv2.FreeVarResolution): ASTv2.ExpressionNode;\n  normalize(\n    expr: ASTv1.Expression | ASTv1.MinimalPathExpression,\n    resolution?: ASTv2.FreeVarResolution\n  ): ASTv2.ExpressionNode {\n    switch (expr.type) {\n      case 'NullLiteral':\n      case 'BooleanLiteral':\n      case 'NumberLiteral':\n      case 'StringLiteral':\n      case 'UndefinedLiteral':\n        return this.block.builder.literal(expr.value, this.block.loc(expr.loc));\n      case 'PathExpression':\n        localAssert(resolution, '[BUG] resolution is required');\n        return this.path(expr, resolution);\n      case 'SubExpression': {\n        // expr.path used to incorrectly have the type ASTv1.Expression\n        if (isLiteral(expr.path)) {\n          assertIllegalLiteral(expr.path, expr.loc);\n        }\n\n        let resolution = this.block.resolutionFor(expr, SexpSyntaxContext);\n\n        if (resolution.result === 'error') {\n          throw generateSyntaxError(\n            `You attempted to invoke a path (\\`${resolution.path}\\`) but ${resolution.head} was not in scope`,\n            expr.loc\n          );\n        }\n\n        return this.block.builder.sexp(\n          this.callParts(expr, resolution.result),\n          this.block.loc(expr.loc)\n        );\n      }\n    }\n  }\n\n  private path(\n    expr: ASTv1.MinimalPathExpression,\n    resolution: ASTv2.FreeVarResolution\n  ): ASTv2.KeywordExpression | ASTv2.PathExpression {\n    let loc = this.block.loc(expr.loc);\n\n    if (\n      expr.head.type === 'VarHead' &&\n      expr.tail.length === 0 &&\n      this.block.isKeyword(expr.head.name)\n    ) {\n      return this.block.builder.keyword(\n        expr.head.name,\n        this.block.table.getKeyword(expr.head.name),\n        loc\n      );\n    }\n\n    let headOffsets = this.block.loc(expr.head.loc);\n\n    let tail = [];\n\n    // start with the head\n    let offset = headOffsets;\n\n    for (let part of expr.tail) {\n      offset = offset.sliceStartChars({ chars: part.length, skipStart: 1 });\n      tail.push(\n        new SourceSlice({\n          loc: offset,\n          chars: part,\n        })\n      );\n    }\n\n    return this.block.builder.path(this.ref(expr.head, resolution), tail, loc);\n  }\n\n  /**\n   * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes\n   * it to an ASTv2 CallParts.\n   */\n  callParts(parts: ASTv1.CallParts, context: ASTv2.FreeVarResolution): CallParts {\n    let { path, params, hash, loc } = parts;\n\n    let callee = this.normalize(path, context);\n    let paramList = params.map((p) => this.normalize(p, ASTv2.STRICT_RESOLUTION));\n    let paramLoc = SpanList.range(paramList, callee.loc.collapse('end'));\n    let namedLoc = this.block.loc(hash.loc);\n    let argsLoc = SpanList.range([paramLoc, namedLoc]);\n\n    let positional = this.block.builder.positional(\n      params.map((p) => this.normalize(p, ASTv2.STRICT_RESOLUTION)),\n      paramLoc\n    );\n\n    let named = this.block.builder.named(\n      hash.pairs.map((p) => this.namedArgument(p)),\n      this.block.loc(hash.loc)\n    );\n\n    switch (callee.type) {\n      case 'Literal':\n        throw generateSyntaxError(\n          `Invalid invocation of a literal value (\\`${callee.value}\\`)`,\n          loc\n        );\n\n      // This really shouldn't be possible, something has gone pretty wrong\n      case 'Interpolate':\n        throw generateSyntaxError(`Invalid invocation of a interpolated string`, loc);\n    }\n\n    return {\n      callee,\n      args: this.block.builder.args(positional, named, argsLoc),\n    };\n  }\n\n  private namedArgument(pair: ASTv1.HashPair): ASTv2.NamedArgument {\n    let offsets = this.block.loc(pair.loc);\n\n    let keyOffsets = offsets.sliceStartChars({ chars: pair.key.length });\n\n    return this.block.builder.namedArgument(\n      new SourceSlice({ chars: pair.key, loc: keyOffsets }),\n      this.normalize(pair.value, ASTv2.STRICT_RESOLUTION)\n    );\n  }\n\n  /**\n   * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.\n   * This method is extremely important, because it is responsible for normalizing free\n   * variables into an an ASTv2.PathHead *with appropriate context*.\n   *\n   * The syntax context is originally determined by the syntactic position that this `PathHead`\n   * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,\n   * the `VariableReference` node bears full responsibility for loose mode rules that control\n   * the behavior of free variables.\n   */\n  private ref(head: ASTv1.PathHead, resolution: ASTv2.FreeVarResolution): ASTv2.VariableReference {\n    let { block } = this;\n    let { builder, table } = block;\n    let offsets = block.loc(head.loc);\n\n    switch (head.type) {\n      case 'ThisHead':\n        if (block.hasBinding('this')) {\n          let [symbol, isRoot] = table.get('this');\n          return block.builder.localVar('this', symbol, isRoot, offsets);\n        }\n        return builder.self(offsets);\n      case 'AtHead': {\n        let symbol = table.allocateNamed(head.name);\n        return builder.at(head.name, symbol, offsets);\n      }\n      case 'VarHead': {\n        if (block.hasBinding(head.name)) {\n          let [symbol, isRoot] = table.get(head.name);\n\n          return block.builder.localVar(head.name, symbol, isRoot, offsets);\n        } else {\n          let context = block.strict ? ASTv2.STRICT_RESOLUTION : resolution;\n          let symbol = block.table.allocateFree(head.name, context);\n\n          return block.builder.freeVar({\n            name: head.name,\n            context,\n            symbol,\n            loc: offsets,\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.\n */\nclass StatementNormalizer {\n  constructor(private readonly block: BlockContext) {}\n\n  normalize(node: ASTv1.Statement): ASTv2.ContentNode | ASTv2.NamedBlock {\n    switch (node.type) {\n      case 'BlockStatement':\n        return this.BlockStatement(node);\n      case 'ElementNode':\n        return new ElementNormalizer(this.block).ElementNode(node);\n      case 'MustacheStatement':\n        return this.MustacheStatement(node);\n\n      // These are the same in ASTv2\n      case 'MustacheCommentStatement':\n        return this.MustacheCommentStatement(node);\n\n      case 'CommentStatement': {\n        let loc = this.block.loc(node.loc);\n        return new ASTv2.HtmlComment({\n          loc,\n          text: loc.slice({ skipStart: 4, skipEnd: 3 }).toSlice(node.value),\n        });\n      }\n\n      case 'TextNode':\n        return new ASTv2.HtmlText({\n          loc: this.block.loc(node.loc),\n          chars: node.chars,\n        });\n    }\n  }\n\n  MustacheCommentStatement(node: ASTv1.MustacheCommentStatement): ASTv2.GlimmerComment {\n    let loc = this.block.loc(node.loc);\n\n    // If someone cares for these cases to have the right loc, feel free to attempt:\n    // {{!}} {{~!}} {{!~}} {{~!~}}\n    // {{!-}} {{~!-}} {{!-~}} {{~!-~}}\n    // {{!--}} {{~!--}} {{!--~}} {{~!--~}}\n    // {{!---}} {{~!---}} {{!---~}} {{~!---~}}\n    // {{!----}} {{~!----}} {{!----~}} {{~!----~}}\n    if (node.value === '') {\n      return new ASTv2.GlimmerComment({\n        loc,\n        text: SourceSlice.synthetic(''),\n      });\n    }\n\n    let source = loc.asString();\n    let span = loc;\n\n    if (node.value.startsWith('-')) {\n      localAssert(\n        /^\\{\\{~?!---/u.test(source),\n        `to start a comment's content with a '-', it must have started with {{!--`\n      );\n      span = span.sliceStartChars({\n        skipStart: source.startsWith('{{~') ? 6 : 5,\n        chars: node.value.length,\n      });\n    } else if (node.value.endsWith('-')) {\n      localAssert(\n        /--~?\\}\\}/u.test(source),\n        `to end a comment's content with a '-', it must have ended with --}}`\n      );\n\n      const skipEnd = source.endsWith('~}}') ? 5 : 4;\n      const skipStart = source.length - node.value.length - skipEnd;\n\n      span = span.slice({\n        skipStart,\n        skipEnd,\n      });\n    } else {\n      span = span.sliceStartChars({\n        skipStart: source.lastIndexOf(node.value),\n        chars: node.value.length,\n      });\n    }\n\n    return new ASTv2.GlimmerComment({\n      loc,\n      text: span.toSlice(node.value),\n    });\n  }\n\n  /**\n   * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement\n   */\n  MustacheStatement(mustache: ASTv1.MustacheStatement): ASTv2.AppendContent {\n    let { path, params, hash, trusting } = mustache;\n    let loc = this.block.loc(mustache.loc);\n    let value: ASTv2.ExpressionNode;\n\n    if (isLiteral(path)) {\n      if (params.length === 0 && hash.pairs.length === 0) {\n        value = this.expr.normalize(path);\n      } else {\n        assertIllegalLiteral(path, loc);\n      }\n    } else {\n      let resolution = this.block.resolutionFor(mustache, AppendSyntaxContext);\n\n      if (resolution.result === 'error') {\n        throw generateSyntaxError(\n          `You attempted to render a path (\\`{{${resolution.path}}}\\`), but ${resolution.head} was not in scope`,\n          loc\n        );\n      }\n\n      // Normalize the call parts in AppendSyntaxContext\n      let callParts = this.expr.callParts(\n        {\n          path,\n          params,\n          hash,\n          loc,\n        },\n        resolution.result\n      );\n\n      value = callParts.args.isEmpty() ? callParts.callee : this.block.builder.sexp(callParts, loc);\n    }\n\n    return this.block.builder.append(\n      {\n        table: this.block.table,\n        trusting,\n        value,\n      },\n      loc\n    );\n  }\n\n  /**\n   * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement\n   */\n  BlockStatement(block: ASTv1.BlockStatement): ASTv2.InvokeBlock {\n    let { program, inverse } = block;\n    let loc = this.block.loc(block.loc);\n\n    // block.path used to incorrectly have the type ASTv1.Expression\n    if (isLiteral(block.path)) {\n      assertIllegalLiteral(block.path, loc);\n    }\n\n    let resolution = this.block.resolutionFor(block, BlockSyntaxContext);\n\n    if (resolution.result === 'error') {\n      throw generateSyntaxError(\n        `You attempted to invoke a path (\\`{{#${resolution.path}}}\\`) but ${resolution.head} was not in scope`,\n        loc\n      );\n    }\n\n    let callParts = this.expr.callParts(block, resolution.result);\n\n    return this.block.builder.blockStatement(\n      assign(\n        {\n          symbols: this.block.table,\n          program: this.Block(program),\n          inverse: inverse ? this.Block(inverse) : null,\n        },\n        callParts\n      ),\n      loc\n    );\n  }\n\n  Block({ body, loc, blockParams }: ASTv1.Block): ASTv2.Block {\n    let child = this.block.child(blockParams);\n    let normalizer = new StatementNormalizer(child);\n    return new BlockChildren(\n      this.block.loc(loc),\n      body.map((b) => normalizer.normalize(b)),\n      this.block\n    ).assertBlock(child.table);\n  }\n\n  private get expr(): ExpressionNormalizer {\n    return new ExpressionNormalizer(this.block);\n  }\n}\n\nclass ElementNormalizer {\n  constructor(private readonly ctx: BlockContext) {}\n\n  /**\n   * Normalizes an ASTv1.ElementNode to:\n   *\n   * - ASTv2.NamedBlock if the tag name begins with `:`\n   * - ASTv2.Component if the tag name matches the component heuristics\n   * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics\n   *\n   * A tag name represents a component if:\n   *\n   * - it begins with `@`\n   * - it is exactly `this` or begins with `this.`\n   * - the part before the first `.` is a reference to an in-scope variable binding\n   * - it begins with an uppercase character\n   */\n  ElementNode(element: ASTv1.ElementNode): ASTv2.ElementNode {\n    let { tag, selfClosing, comments } = element;\n    let loc = this.ctx.loc(element.loc);\n\n    let [tagHead, ...rest] = asPresentArray(tag.split('.'));\n\n    // the head, attributes and modifiers are in the current scope\n    let path = this.classifyTag(tagHead, rest, element.loc);\n\n    let attrs = element.attributes.filter((a) => a.name[0] !== '@').map((a) => this.attr(a));\n    let args = element.attributes.filter((a) => a.name[0] === '@').map((a) => this.arg(a));\n\n    let modifiers = element.modifiers.map((m) => this.modifier(m));\n\n    // the element's block params are in scope for the children\n    let child = this.ctx.child(element.blockParams);\n    let normalizer = new StatementNormalizer(child);\n\n    let childNodes = element.children.map((s) => normalizer.normalize(s));\n\n    let el = this.ctx.builder.element({\n      selfClosing,\n      attrs,\n      componentArgs: args,\n      modifiers,\n      comments: comments.map((c) => new StatementNormalizer(this.ctx).MustacheCommentStatement(c)),\n    });\n\n    let children = new ElementChildren(el, loc, childNodes, this.ctx);\n\n    let offsets = this.ctx.loc(element.loc);\n    let tagOffsets = offsets.sliceStartChars({ chars: tag.length, skipStart: 1 });\n\n    if (path === 'ElementHead') {\n      if (tag[0] === ':') {\n        return children.assertNamedBlock(\n          tagOffsets.slice({ skipStart: 1 }).toSlice(tag.slice(1)),\n          child.table\n        );\n      } else {\n        return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);\n      }\n    }\n\n    if (element.selfClosing) {\n      return el.selfClosingComponent(path, loc);\n    } else {\n      let blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);\n      return el.componentWithNamedBlocks(path, blocks, loc);\n    }\n  }\n\n  private modifier(m: ASTv1.ElementModifierStatement): ASTv2.ElementModifier {\n    // modifier.path used to incorrectly have the type ASTv1.Expression\n    if (isLiteral(m.path)) {\n      assertIllegalLiteral(m.path, m.loc);\n    }\n\n    let resolution = this.ctx.resolutionFor(m, ModifierSyntaxContext);\n\n    if (resolution.result === 'error') {\n      throw generateSyntaxError(\n        `You attempted to invoke a path (\\`{{${resolution.path}}}\\`) as a modifier, but ${resolution.head} was not in scope`,\n        m.loc\n      );\n    }\n\n    let callParts = this.expr.callParts(m, resolution.result);\n    return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));\n  }\n\n  /**\n   * This method handles attribute values that are curlies, as well as curlies nested inside of\n   * interpolations:\n   *\n   * ```hbs\n   * <a href={{url}} />\n   * <a href=\"{{url}}.html\" />\n   * ```\n   */\n  private mustacheAttr(mustache: ASTv1.MustacheStatement): ASTv2.ExpressionNode {\n    let { path, params, hash, loc } = mustache;\n\n    if (isLiteral(path)) {\n      if (params.length === 0 && hash.pairs.length === 0) {\n        return this.expr.normalize(path);\n      } else {\n        assertIllegalLiteral(path, loc);\n      }\n    }\n\n    // Normalize the call parts in AttrValueSyntaxContext\n    let resolution = this.ctx.resolutionFor(mustache, AttrValueSyntaxContext);\n\n    if (resolution.result === 'error') {\n      throw generateSyntaxError(\n        `You attempted to render a path (\\`{{${resolution.path}}}\\`), but ${resolution.head} was not in scope`,\n        mustache.loc\n      );\n    }\n\n    let sexp = this.ctx.builder.sexp(\n      this.expr.callParts(mustache as ASTv1.CallParts, resolution.result),\n      this.ctx.loc(mustache.loc)\n    );\n\n    // If there are no params or hash, just return the function part as its own expression\n    if (sexp.args.isEmpty()) {\n      return sexp.callee;\n    } else {\n      return sexp;\n    }\n  }\n\n  /**\n   * attrPart is the narrowed down list of valid attribute values that are also\n   * allowed as a concat part (you can't nest concats).\n   */\n  private attrPart(part: ASTv1.MustacheStatement | ASTv1.TextNode): {\n    expr: ASTv2.ExpressionNode;\n    trusting: boolean;\n  } {\n    switch (part.type) {\n      case 'MustacheStatement':\n        return { expr: this.mustacheAttr(part), trusting: part.trusting };\n      case 'TextNode':\n        return {\n          expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),\n          trusting: true,\n        };\n    }\n  }\n\n  private attrValue(part: ASTv1.MustacheStatement | ASTv1.TextNode | ASTv1.ConcatStatement): {\n    expr: ASTv2.ExpressionNode;\n    trusting: boolean;\n  } {\n    switch (part.type) {\n      case 'ConcatStatement': {\n        let parts = part.parts.map((p) => this.attrPart(p).expr);\n        return {\n          expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),\n          trusting: false,\n        };\n      }\n      default:\n        return this.attrPart(part);\n    }\n  }\n\n  private attr(m: ASTv1.AttrNode): ASTv2.HtmlOrSplatAttr {\n    localAssert(m.name[0] !== '@', 'An attr name must not start with `@`');\n\n    if (m.name === '...attributes') {\n      return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));\n    }\n\n    let offsets = this.ctx.loc(m.loc);\n    let nameSlice = offsets.sliceStartChars({ chars: m.name.length }).toSlice(m.name);\n    let value = this.attrValue(m.value);\n\n    return this.ctx.builder.attr(\n      { name: nameSlice, value: value.expr, trusting: value.trusting },\n      offsets\n    );\n  }\n\n  // An arg curly <Foo @bar={{...}} /> is the same as an attribute curly for\n  // our purposes, except that in loose mode <Foo @bar={{baz}} /> is an error:\n  private checkArgCall(arg: ASTv1.AttrNode): void {\n    let { value } = arg;\n\n    if (value.type !== 'MustacheStatement') {\n      return;\n    }\n\n    if (value.params.length !== 0 || value.hash.pairs.length !== 0) {\n      return;\n    }\n\n    let { path } = value;\n\n    if (path.type !== 'PathExpression') {\n      return;\n    }\n\n    if (path.tail.length > 0) {\n      return;\n    }\n\n    let resolution = this.ctx.resolutionFor(path, () => {\n      // We deliberately don't want this to resolve anything. The purpose of\n      // calling `resolutionFor` here is to check for strict mode, in-scope\n      // local variables, etc.\n      return null;\n    });\n\n    if (resolution.result === 'error' && resolution.path !== 'has-block') {\n      throw generateSyntaxError(\n        `You attempted to pass a path as argument (\\`${arg.name}={{${resolution.path}}}\\`) but ${resolution.head} was not in scope. Try:\\n` +\n          `* \\`${arg.name}={{this.${resolution.path}}}\\` if this is meant to be a property lookup, or\\n` +\n          `* \\`${arg.name}={{(${resolution.path})}}\\` if this is meant to invoke the resolved helper, or\\n` +\n          `* \\`${arg.name}={{helper \"${resolution.path}\"}}\\` if this is meant to pass the resolved helper by value`,\n        arg.loc\n      );\n    }\n  }\n\n  private arg(arg: ASTv1.AttrNode): ASTv2.ComponentArg {\n    localAssert(arg.name[0] === '@', 'An arg name must start with `@`');\n    this.checkArgCall(arg);\n\n    let offsets = this.ctx.loc(arg.loc);\n    let nameSlice = offsets.sliceStartChars({ chars: arg.name.length }).toSlice(arg.name);\n    let value = this.attrValue(arg.value);\n\n    return this.ctx.builder.arg(\n      { name: nameSlice, value: value.expr, trusting: value.trusting },\n      offsets\n    );\n  }\n\n  /**\n   * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the\n   * element is a component) or `'ElementHead'` (if the element is a simple element).\n   *\n   * Rules:\n   *\n   * 1. If the variable is an `@arg`, return an `AtHead`\n   * 2. If the variable is `this`, return a `ThisHead`\n   * 3. If the variable is in the current scope:\n   *   a. If the scope is the root scope, then return a Free `LocalVarHead`\n   *   b. Else, return a standard `LocalVarHead`\n   * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error\n   * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)\n   * 6. Otherwise, return `'ElementHead'`\n   */\n  private classifyTag(\n    variable: string,\n    tail: string[],\n    loc: SourceSpan\n  ): ASTv2.ExpressionNode | 'ElementHead' {\n    let uppercase = isUpperCase(variable);\n    let inScope = variable[0] === '@' || variable === 'this' || this.ctx.hasBinding(variable);\n\n    if (this.ctx.strict && !inScope) {\n      if (uppercase) {\n        throw generateSyntaxError(\n          `Attempted to invoke a component that was not in scope in a strict mode template, \\`<${variable}>\\`. If you wanted to create an element with that name, convert it to lowercase - \\`<${variable.toLowerCase()}>\\``,\n          loc\n        );\n      }\n\n      // In strict mode, values are always elements unless they are in scope\n      return 'ElementHead';\n    }\n\n    // Since the parser handed us the HTML element name as a string, we need\n    // to convert it into an ASTv1 path so it can be processed using the\n    // expression normalizer.\n    let isComponent = inScope || uppercase;\n\n    let variableLoc = loc.sliceStartChars({ skipStart: 1, chars: variable.length });\n\n    let tailLength = tail.reduce((accum, part) => accum + 1 + part.length, 0);\n    let pathEnd = variableLoc.getEnd().move(tailLength);\n    let pathLoc = variableLoc.withEnd(pathEnd);\n\n    if (isComponent) {\n      let path = b.path({\n        head: b.head({ original: variable, loc: variableLoc }),\n        tail,\n        loc: pathLoc,\n      });\n\n      let resolution = this.ctx.isLexicalVar(variable)\n        ? { result: ASTv2.STRICT_RESOLUTION }\n        : this.ctx.resolutionFor(path, ComponentSyntaxContext);\n\n      if (resolution.result === 'error') {\n        throw generateSyntaxError(\n          `You attempted to invoke a path (\\`<${resolution.path}>\\`) but ${resolution.head} was not in scope`,\n          loc\n        );\n      }\n\n      return new ExpressionNormalizer(this.ctx).normalize(path, resolution.result);\n    } else {\n      this.ctx.table.allocateFree(variable, ASTv2.STRICT_RESOLUTION);\n    }\n\n    // If the tag name wasn't a valid component but contained a `.`, it's\n    // a syntax error.\n    if (tail.length > 0) {\n      throw generateSyntaxError(\n        `You used ${variable}.${tail.join('.')} as a tag name, but ${variable} is not in scope`,\n        loc\n      );\n    }\n\n    return 'ElementHead';\n  }\n\n  private get expr(): ExpressionNormalizer {\n    return new ExpressionNormalizer(this.ctx);\n  }\n}\n\nclass Children {\n  readonly namedBlocks: ASTv2.NamedBlock[];\n  readonly hasSemanticContent: boolean;\n  readonly nonBlockChildren: ASTv2.ContentNode[];\n\n  constructor(\n    readonly loc: SourceSpan,\n    readonly children: (ASTv2.ContentNode | ASTv2.NamedBlock)[],\n    readonly block: BlockContext\n  ) {\n    this.namedBlocks = children.filter((c): c is ASTv2.NamedBlock => c instanceof ASTv2.NamedBlock);\n    this.hasSemanticContent = Boolean(\n      children.filter((c): c is ASTv2.ContentNode => {\n        if (c instanceof ASTv2.NamedBlock) {\n          return false;\n        }\n        switch (c.type) {\n          case 'GlimmerComment':\n          case 'HtmlComment':\n            return false;\n          case 'HtmlText':\n            return !/^\\s*$/u.test(c.chars);\n          default:\n            return true;\n        }\n      }).length\n    );\n    this.nonBlockChildren = children.filter(\n      (c): c is ASTv2.ContentNode => !(c instanceof ASTv2.NamedBlock)\n    );\n  }\n}\n\nclass TemplateChildren extends Children {\n  assertTemplate(table: ProgramSymbolTable): ASTv2.Template {\n    if (isPresentArray(this.namedBlocks)) {\n      throw generateSyntaxError(`Unexpected named block at the top-level of a template`, this.loc);\n    }\n\n    return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));\n  }\n}\n\nclass BlockChildren extends Children {\n  assertBlock(table: BlockSymbolTable): ASTv2.Block {\n    if (isPresentArray(this.namedBlocks)) {\n      throw generateSyntaxError(`Unexpected named block nested in a normal block`, this.loc);\n    }\n\n    return this.block.builder.block(table, this.nonBlockChildren, this.loc);\n  }\n}\n\nclass ElementChildren extends Children {\n  constructor(\n    private el: BuildElement,\n    loc: SourceSpan,\n    children: (ASTv2.ContentNode | ASTv2.NamedBlock)[],\n    block: BlockContext\n  ) {\n    super(loc, children, block);\n  }\n\n  assertNamedBlock(name: SourceSlice, table: BlockSymbolTable): ASTv2.NamedBlock {\n    if (this.el.base.selfClosing) {\n      throw generateSyntaxError(\n        `<:${name.chars}/> is not a valid named block: named blocks cannot be self-closing`,\n        this.loc\n      );\n    }\n\n    if (isPresentArray(this.namedBlocks)) {\n      throw generateSyntaxError(\n        `Unexpected named block inside <:${name.chars}> named block: named blocks cannot contain nested named blocks`,\n        this.loc\n      );\n    }\n\n    if (!isLowerCase(name.chars)) {\n      throw generateSyntaxError(\n        `<:${name.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,\n        this.loc\n      );\n    }\n\n    if (\n      this.el.base.attrs.length > 0 ||\n      this.el.base.componentArgs.length > 0 ||\n      this.el.base.modifiers.length > 0\n    ) {\n      throw generateSyntaxError(\n        `named block <:${name.chars}> cannot have attributes, arguments, or modifiers`,\n        this.loc\n      );\n    }\n\n    let offsets = SpanList.range(this.nonBlockChildren, this.loc);\n\n    return this.block.builder.namedBlock(\n      name,\n      this.block.builder.block(table, this.nonBlockChildren, offsets),\n      this.loc\n    );\n  }\n\n  assertElement(name: SourceSlice, hasBlockParams: boolean): ASTv2.SimpleElement {\n    if (hasBlockParams) {\n      throw generateSyntaxError(\n        `Unexpected block params in <${name.chars}>: simple elements cannot have block params`,\n        this.loc\n      );\n    }\n\n    if (isPresentArray(this.namedBlocks)) {\n      let names = this.namedBlocks.map((b) => b.name);\n\n      if (names.length === 1) {\n        throw generateSyntaxError(\n          `Unexpected named block <:foo> inside <${name.chars}> HTML element`,\n          this.loc\n        );\n      } else {\n        let printedNames = names.map((n) => `<:${n.chars}>`).join(', ');\n        throw generateSyntaxError(\n          `Unexpected named blocks inside <${name.chars}> HTML element (${printedNames})`,\n          this.loc\n        );\n      }\n    }\n\n    return this.el.simple(name, this.nonBlockChildren, this.loc);\n  }\n\n  assertComponent(\n    name: string,\n    table: BlockSymbolTable,\n    hasBlockParams: boolean\n  ): PresentArray<ASTv2.NamedBlock> {\n    if (isPresentArray(this.namedBlocks) && this.hasSemanticContent) {\n      throw generateSyntaxError(\n        `Unexpected content inside <${name}> component invocation: when using named blocks, the tag cannot contain other content`,\n        this.loc\n      );\n    }\n\n    if (isPresentArray(this.namedBlocks)) {\n      if (hasBlockParams) {\n        throw generateSyntaxError(\n          `Unexpected block params list on <${name}> component invocation: when passing named blocks, the invocation tag cannot take block params`,\n          this.loc\n        );\n      }\n\n      let seenNames = new Set<string>();\n\n      for (let block of this.namedBlocks) {\n        let name = block.name.chars;\n\n        if (seenNames.has(name)) {\n          throw generateSyntaxError(\n            `Component had two named blocks with the same name, \\`<:${name}>\\`. Only one block with a given name may be passed`,\n            this.loc\n          );\n        }\n\n        if (\n          (name === 'inverse' && seenNames.has('else')) ||\n          (name === 'else' && seenNames.has('inverse'))\n        ) {\n          throw generateSyntaxError(\n            `Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>`,\n            this.loc\n          );\n        }\n\n        seenNames.add(name);\n      }\n\n      return this.namedBlocks;\n    } else {\n      return [\n        this.block.builder.namedBlock(\n          SourceSlice.synthetic('default'),\n          this.block.builder.block(table, this.nonBlockChildren, this.loc),\n          this.loc\n        ),\n      ];\n    }\n  }\n}\n\nfunction isLiteral(node: ASTv1.Expression): node is ASTv1.Literal {\n  switch (node.type) {\n    case 'StringLiteral':\n    case 'BooleanLiteral':\n    case 'NumberLiteral':\n    case 'UndefinedLiteral':\n    case 'NullLiteral':\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction assertIllegalLiteral(node: ASTv1.Literal, loc: SourceSpan): never {\n  let value = node.type === 'StringLiteral' ? JSON.stringify(node.value) : String(node.value);\n  throw generateSyntaxError(`Unexpected literal \\`${value}\\``, loc);\n}\n\nfunction printPath(node: ASTv1.PathExpression | ASTv1.CallNode): string {\n  if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {\n    return printPath(node.path);\n  } else {\n    return new Printer({ entityEncoding: 'raw' }).print(node);\n  }\n}\n\nfunction printHead(node: ASTv1.PathExpression | ASTv1.CallNode): string {\n  if (node.type === 'PathExpression') {\n    return node.head.original;\n  } else if (node.path.type === 'PathExpression') {\n    return printHead(node.path);\n  } else {\n    return new Printer({ entityEncoding: 'raw' }).print(node);\n  }\n}\n"],"names":["ATTR_VALUE_REGEX_TEST","ATTR_VALUE_REGEX_REPLACE","RegExp","source","TEXT_REGEX_TEST","TEXT_REGEX_REPLACE","attrValueReplacer","char","charCodeAt","textReplacer","escapeAttrValue","attrValue","test","replace","sortByLoc","a","b","loc","isInvisible","startPosition","line","column","voidMap","Set","getVoidTags","NON_WHITESPACE","isVoidTag","tag","has","toLowerCase","Printer","constructor","options","buffer","this","handledByOverride","node","ensureLeadingWhitespace","undefined","override","result","Node","type","TopLevelStatement","Expression","ConcatStatement","Hash","HashPair","ElementModifierStatement","expression","Literal","PathExpression","SubExpression","literal","StringLiteral","BooleanLiteral","NumberLiteral","UndefinedLiteral","NullLiteral","statement","MustacheStatement","BlockStatement","MustacheCommentStatement","CommentStatement","TextNode","ElementNode","Block","Template","AttrNode","template","TopLevelStatements","body","block","chained","statements","forEach","el","OpenElementNode","children","CloseElementNode","parts","attributes","modifiers","comments","sort","part","blockParams","length","BlockParams","selfClosing","attr","name","value","startsWith","chars","AttrNodeValue","quote","entityEncoding","includes","text","isInAttr","escapeText","mustache","trusting","strip","open","path","Params","params","hash","close","inverseStrip","openStrip","program","inverse","closeStrip","join","concat","comment","mod","original","sexp","param","pairs","pair","key","str","JSON","stringify","bool","String","number","print","build","ast","isKeyword","word","KEYWORDS_TYPES","action","component","debugger","each","helper","if","let","log","modifier","mount","mut","outlet","readonly","unbound","unless","yield","isPresentArray","list","getLast","getFirst","UNKNOWN_POSITION","Object","freeze","SYNTHETIC_LOCATION","start","end","NON_EXISTENT_LOCATION","BROKEN_LOCATION","CHAR_OFFSET_KIND","HBS_POSITION_KIND","INTERNAL_SYNTHETIC_KIND","NON_EXISTENT_KIND","BROKEN_KIND","MatchAny","IsInvisible","WhenList","whens","_whens","first","kind","when","match","When","get","pattern","or","_map","set","add","out","patternFor","exact","fallback","push","Map","callback","Matcher","validate","left","right","matchFor","nesteds","SourceSlice","synthetic","offsets","src","load","slice","getString","serialize","SourceSpan","NON_EXISTENT","InvisibleSpan","wrap","serialized","forCharPositions","Array","isArray","broken","assertNever","forHbsLoc","HbsPosition","HbsSpan","startPos","endPos","CharPosition","CharPositionSpan","pos","data","getStart","getEnd","span","toHbsSpan","toHbsLoc","module","getModule","endPosition","toJSON","withStart","other","withEnd","asString","toSlice","expected","position","locDidUpdate","collapse","where","collapsed","extend","skipStart","skipEnd","move","sliceStartChars","sliceEndChars","locPosSpan","charPositions","charPos","toHbsPos","BROKEN","toCharPosSpan","charPosSpan","providedHbsLoc","hbsPositions","updateProvided","edge","hbsPos","toCharPos","string","InvisiblePosition","m","rightCharPos","leftCharPos","_","SourceOffset","forHbsPos","offset","eql","until","by","_locPos","hbs","locPos","hbsPosFor","_charPos","charPosNumber","charPosFor","Source","from","meta","moduleName","offsetFor","spanFor","seenLines","seenChars","nextLine","indexOf","sourceLength","SpanList","range","map","getRangeOffset","_span","last","hasSpan","maybeLoc","location","generateSyntaxError","message","code","quotedCode","split","error","Error","visitorKeys","TraversalError","parent","call","stack","prototype","create","cannotRemoveNode","cannotReplaceNode","cannotReplaceOrRemoveInKeyHandlerYet","WalkerPath","parentKey","parentNode","parents","Symbol","iterator","PathParentsIterator","next","done","getEnterFunction","handler","enter","getExitFunction","exit","visitNode","visitor","nodeType","Program","All","getNodeHandler","visitArray","keys","i","visitKey","keyEnter","keyExit","keyHandler","keyVisitor","getKeyHandler","assignKey","array","spliceArray","index","splice","traverse","Walker","order","visit","pop","walkBody","walker","child","appendChild","childrenFor","isHBSLiteral","_SOURCE","SOURCE","buildVar","var","buildLoc","buildPath","head","tail","headNode","buildHead","buildLiteral","buildHash","buildBlockParams","p","buildBlockItself","blockItself","buildTemplate","args","startLine","startColumn","endLine","endColumn","_source","publicBuilder","_defaultBlock","_elseBlock","defaultBlock","elseBlock","mustacheComment","element","attrs","openTag","closeTag","_closeTag","endsWith","elementModifier","sexpr","fullPath","at","atName","boolean","null","DEFAULT_STRIP","defineProperty","enumerable","buildLegacyMustache","_selfClosing","shift","values","unshift","buildLegacyPath","_name","buildLegacyLiteral","Parser","entityParser","EntityParser","namedCharRefs","mode","elementStack","currentAttribute","currentNode","lines","tokenizer","EventedTokenizer","finish","assign","currentAttr","currentTag","currentStartTag","currentEndTag","currentComment","currentData","acceptNode","currentElement","sourceForNode","endNode","lastLine","lastColumn","firstLine","currentLine","firstColumn","BEFORE_ATTRIBUTE_NAME","HandlebarsNodeVisitors","parse","parseProgram","pendingError","eof","poppedNode","state","appendToCommentData","acceptCallNodes","repairedBlock","repairBlock","content","limit","nameStart","rawMustache","escaped","addElementModifier","beginAttributeValue","finishAttributeValue","transitionTo","appendDynamicAttributeValuePart","finalizeTextPart","isDynamic","currentPart","startTextPart","ContentStatement","columns","difference","lineCount","calculateRightStrippedOffsets","updateTokenizerLocation","tokenizePart","flushData","rawComment","PartialStatement","partial","PartialBlockStatement","partialBlock","Decorator","decorator","DecoratorBlock","decoratorBlock","pathHead","thisHead","undef","nul","super","compiler","toString","e","printLiteral","fallbackStart","endProgram","isSpace","TokenizerEventHandlers","reset","beginComment","tagOpenLine","tagOpenColumn","finishComment","beginData","appendToData","finishData","tagOpen","beginStartTag","nameEnd","beginEndTag","finishTag","finishStartTag","finishEndTag","nameLoc","isVoid","closeTagStart","validateEndTag","markTagAsSelfClosing","appendToTagName","beginAttribute","isQuoted","valueSpan","appendToAttributeName","parsePossibleBlockParams","appendToAttributeValue","lastPart","current","tokenizerPos","assembleAttributeValue","attribute","ID_INVERSE_PATTERN","as","handlers","PossibleAs","consume","BeforeStartPipe","BeforeBlockParamName","BlockParamName","AfterEndPipe","Done","peek","reportSyntaxError","assembleConcatenatedValue","syntax","preprocess","builders","CodemodEntityParser","input","parseWithoutProcessing","parseOptions","locals","plugins","transform","addTokens","tokensSet","scopedTokens","maybePathName","possbleToken","charAt","includeHtmlElements","substr","potentialLocal","getPathName","maybeFirstPathSegment","getTemplateLocals","html","includeKeywords","tokens","s","filter","token","fields","Args","empty","positional","PositionalArguments","named","NamedArguments","nth","isEmpty","exprs","size","entries","entry","NamedArgument","HtmlAttr","SplatAttr","ComponentArg","toNamedArgument","ElementModifier","GlimmerComment","HtmlText","HtmlComment","AppendContent","callee","InvokeBlock","InvokeComponent","componentArgs","SimpleElement","LiteralExpression","KeywordExpression","CallExpression","InterpolateExpression","NamedBlocks","blocks","NamedBlock","ThisReference","ArgReference","LocalVarReference","FreeVarReference","HELPER_VAR_NS","MODIFIER_VAR_NS","COMPONENT_VAR_NS","STRICT_RESOLUTION","resolution","SexpOpcodes","GetStrictKeyword","isAngleBracket","HTML_RESOLUTION","LooseModeResolution","namespaced","namespace","append","trustingAppend","namespaces","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHead","GetFreeAsModifierHead","GetFreeAsComponentHead","HELPER_NAMESPACE","MODIFIER_NAMESPACE","COMPONENT_NAMESPACE","SymbolTable","top","keywords","ProgramSymbolTable","symbols","allocate","BlockSymbolTable","templateLocals","upvars","dict","usedTemplateLocals","root","hasLexical","lexicalScope","hasKeyword","getKeyword","allocateFree","ASTv2","getUsedTemplateLocals","getLocalsMap","getDebugInfo","customizeComponentName","allocateNamed","allocateBlock","identifier","slots","local","slot","symbol","fromEntries","Builder","table","scope","namedBlock","simpleNamedBlock","BuildElement","namedArgument","splatAttr","arg","ref","keyword","self","freeVar","context","localVar","isTemplateLocal","interpolate","namedBlocks","blockStatement","blocksLoc","base","builder","simple","selfClosingComponent","componentWithDefaultBlock","componentWithNamedBlocks","SexpSyntaxContext","isSimpleCallee","ModifierSyntaxContext","BlockSyntaxContext","ComponentSyntaxContext","isSimplePath","AttrValueSyntaxContext","AppendSyntaxContext","isSimple","normalize","normalizeOptions","strictMode","BlockContext","normalizer","StatementNormalizer","astV2","TemplateChildren","assertTemplate","strict","resolutionFor","isFreeVar","r","printPath","printHead","isLexicalVar","variable","hasBinding","ExpressionNormalizer","expr","isLiteral","assertIllegalLiteral","callParts","paramList","paramLoc","namedLoc","argsLoc","keyOffsets","isRoot","ElementNormalizer","lastIndexOf","BlockChildren","assertBlock","ctx","tagHead","rest","classifyTag","childNodes","c","ElementChildren","tagOffsets","assertNamedBlock","assertElement","assertComponent","mustacheAttr","attrPart","nameSlice","checkArgCall","uppercase","toUpperCase","inScope","isComponent","variableLoc","tailLength","reduce","accum","pathEnd","pathLoc","Children","hasSemanticContent","Boolean","nonBlockChildren","hasBlockParams","names","printedNames","n","seenNames"],"mappings":"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"}